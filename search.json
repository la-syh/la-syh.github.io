[{"title":"2024ICPC昆明","url":"/post/ae0074f0.html","content":"\n[比赛链接](https://codeforces.com/gym/105588)\n\n<!--more-->\n\n## B. Brackets\n\n首先，选出的两段要么均为空，要么一个为一堆左括号，另一个为一堆右括号且它们互补。\n\n考虑给定的每一段区间，若它消除后剩下的是一堆左括号，则将剩下的那些左括号的哈希值塞进一个`std::map`中，然后将所有括号取反并翻转序列，重新做如上操作并将哈希值塞进另一个`std::map`中，这样就分别求得了“留下来的是左括号的序列的哈希值”和“留下来的是右括号的序列所能匹配的左括号序列的哈希值”，将它们贪心地匹配即可。\n\n问题在于如何求得这些区间消除后的哈希值：从左往右依次考虑每个括号并维护一个栈，如果遇到一个左括号则将它入栈，否则如果它与栈顶匹配，则消除，否则清空栈。\n\n当考虑完第 $r$ 个括号时，处理右端点为 $l$ 的询问，设其左端点为 $l$：\n- 如果左端点在某对匹配的括号内部，则该区间消除后的前缀一定是一个右括号（这对匹配的括号中的右括号无法消除），无需处理。\n- 否则栈中所有位于该左端点右侧的左括号即为消除完后剩下的左括号序列，计算它的哈希值即可。\n\n总时间复杂度为 $\\mathcal{O}(n + m \\log m)$，若用`std::unordered_map`可以做到线性。\n\n{% fold B. Brackets 示例代码 %}\n```cpp B. Brackets\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull BASE = 131;\nmap<char, int> Map;\n\nconst int N = 5e5 + 10;\nint n, m, A[N];\null Base[N];\nvector<int> L[N];\nint ans;\n\nmap<ull, int> calc() {\n    map<ull, int> f;\n    static int stk[N], sz[N], tp[N];\n    static ull hash_val[N];\n    int lim = 0, top = 0;\n    for(int i = 1; i <= n; i ++) {\n        if(A[i] & 1) {\n            if((A[stk[top]] ^ A[i]) != 1) \n                top = 0, lim = i;\n            else \n                top --;\n        } else {\n            stk[++top] = i;\n            hash_val[top] = hash_val[top - 1] * BASE + A[i];\n        }\n        sz[i] = top, tp[i] = stk[top];\n        for(int j : L[i]) if(j >= lim) {\n            if(sz[i] < sz[j] || tp[j] != stk[sz[j]]) \n                continue;\n            if(sz[i] > sz[j]) {\n                ull hash = hash_val[top] - hash_val[sz[j]] * Base[sz[i] - sz[j]];\n                f[hash] ++;\n            } else ans ++;\n        }\n    }\n    return f;\n}\n\ninline void solve() {\n    cin >> n >> m;\n    string S; cin >> S;\n    vector<pair<int, int>> in(m);\n    for(int i = 0; i < m; i ++)\n        cin >> in[i].first >> in[i].second;\n    for(int i = 0; i < n; i ++)\n        A[i + 1] = Map[S[i]];\n    for(auto [l, r] : in) L[r].emplace_back(l - 1);\n    ans = 0;\n    auto f = calc();\n    for(int i = 1; i <= n; i ++)\n        A[i] ^= 1, L[i].clear();\n    reverse(A + 1, A + n + 1);\n    for(int i = 0; i < m; i ++) {\n        in[i].first = n - in[i].first + 1;\n        in[i].second = n - in[i].second + 1;\n        swap(in[i].first, in[i].second);\n        L[in[i].second].emplace_back(in[i].first - 1);\n    }\n    auto g = calc();\n    for(int i = 1; i <= n; i ++)\n        L[i].clear();\n    ans /= 4;\n    for(auto [x, y] : f) ans += min(y, g[x]);\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    Base[0] = 1;\n    for(int i = 1; i < N; i ++)\n        Base[i] = Base[i - 1] * BASE;\n    Map['('] = 2, Map[')'] = 3, Map['['] = 4, Map[']'] = 5;\n    Map['{'] = 6, Map['}'] = 7, Map['<'] = 8, Map['>'] = 9;\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## C. Coin\n\n考虑从最后倒推回去，这需要两部分的计算：\n\n- 操作需要几轮才会结束\n- 操作后的第 $p$ 个位置在操作前的位置\n\n先考虑第一部分，一次操作会使元素数量减少 $\\lceil \\frac{n}{k} \\rceil$，这是个经典的整除分块形式，$k$ 接近 $n$ 的时候，次数约为 $n$，暴力模拟无法接受，所以考虑将 $\\lceil \\frac{n}{k} \\rceil$ 相同的段一起处理。\n\n设 $\\lceil \\frac{n}{k} \\rceil=d$，要找到一个最小的 $c$ 使得 $\\lceil \\frac{n-cd}{k} \\rceil < d$，化为不等式处理，即 $\\frac{n-cd}{k}\\le d - 1$，解出 $c \\ge \\frac{n-k(d-1)}{d}$，所以这段的轮数为 $c=\\lceil \\frac{n-k(d-1)}{d} \\rceil=\\lfloor \\frac{n-k(d-1)-1}{d} \\rfloor + 1$。\n\n然后考虑第二部分，如果操作一次后在第 $p$ 个位置，那么对它及前面的每 $k-1$ 个元素，都是 $k$ 个元素删掉一个元素形成的（最后一段可能不足 $k-1$ 个元素），因此在它前面的被删掉的元素数为 $\\lceil \\frac{p}{k-1} \\rceil$，因此它原先是第 $p+\\lceil \\frac{p}{k-1} \\rceil$ 个元素。\n\n注意到 $ \\lceil \\frac{p}{k-1} \\rceil $ 的变化次数也是 $\\mathcal{O}(\\sqrt n)$ 的，所以同样类似地整除分块处理即可，总时间复杂度 $ \\mathcal{O}(\\sqrt n) $。\n\n{% fold C. Coin 示例代码 %}\n```cpp C. Coin\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline long long f(long long n, long long k) {\n    // 计算游戏需要几轮才能结束\n    long long ans = 0;\n    while(n) {\n        long long d = (n + k - 1) / k;\n        long long c = (n - k * (d - 1) - 1) / d + 1;\n        n -= c * d; ans += c;\n    }\n    return ans - 1;\n}\nlong long g(long long p, long long k, long long C) {\n    // 这里传进的 k 实际上为分母 k - 1\n    // C 表示剩余轮数\n    if(C == 0) return p;\n    long long d = (p + k - 1) / k;\n    long long x = (k * d - p) / d + 1;\n    x = min(x, C);\n    return g(p + x * d, k, C - x);\n}\n\ninline void solve() {\n    long long n, k; cin >> n >> k;\n    cout << g(1, k - 1, f(n, k)) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## D. Dolls\n\n**引理**：若一个序列可以被完全合并，则它的任一子区间都可以被完全合并，\n\n根据引理可以得到：若一个区间不可以被完全合并，则所有包含它的区间都不能被完全合并。\n\n因此可以从左往右考虑，每次贪心地合并最长的一段区间，否则不会更优。\n\n给定左端点，二分最大的可能的右端点，问题化为如何检查一个序列是否可以被完全合并。不断合并两个相邻的、紧挨着的套娃，若最后只剩下一个套娃则可以被完全合并（例如，$[2, 4]$ 与 $[5, 5]$ 就是两个紧挨着的套娃，它们合并变为 $[2, 5]$），注意这里需要先离散化。\n\n如果每次右端点初始值都设为 $n$，那么总的时间复杂度为 $\\mathcal{O}(n^2 \\log^2 n)$，无法承受，我们需要保证二分的长度和为 $\\mathcal{O}(n)$ 级别的，这样时间复杂度就降为 $\\mathcal{O}(n \\log^2 n)$，为此，可以对每个左端点先倍增出第一个不可合并的右端点位置（倍增检查的的区间长度为 $2^k$），并将它设为二分的右端点，此时区间长度不超过二倍的最长区间长度，因此二分的长度和不超过 $2n$，总时间复杂度降为 $\\mathcal{O}(n \\log^2 n)$。\n\n{% fold D. Dolls 示例代码 %}\n```cpp D. Dolls\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, A[N];\n\ninline bool merge_check(pair<int, int> a, pair<int, int> b) {\n    if(a.first > b.first) swap(a, b);\n    return a.second + 1 == b.first;\n}\ninline pair<int, int> merge(pair<int, int> a, pair<int, int> b) {\n    if(a.first > b.first) swap(a, b);\n    return {a.first, b.second};\n}\n\ninline bool check(int l, int r) {\n    vector<int> v(A + l, A + r + 1);\n    vector<int> lsh = v;\n    int n = r - l + 1;\n    sort(lsh.begin(), lsh.end());\n    for(int i = 0; i < n; i ++)\n        v[i] = lower_bound(lsh.begin(), lsh.end(), v[i]) - lsh.begin();\n    vector<pair<int, int>> stk;\n    stk.push_back({v[0], v[0]});\n    for(int i = 1; i < n; i ++) {\n        stk.push_back({v[i], v[i]});\n        while(stk.size() >= 2 && merge_check(stk[stk.size() - 2], stk[stk.size() - 1])) {\n            stk[stk.size() - 2] = merge(stk[stk.size() - 2], stk[stk.size() - 1]);\n            stk.pop_back();\n        }\n    }\n    return stk.size() == 1;\n}\n\ninline void solve() {\n    cin >> n;\n    for(int i = 1; i <= n; i ++)\n        cin >> A[i];\n    int s = 0;\n    for(int l = 1; l <= n; l ++) {\n        int L = l + 1, R = l + 1, d = 2;\n        while(R <= n && check(l, R)) \n            d <<= 1, R = min(n + 1, l + d - 1);\n        R --;\n        while(L < R) {\n            int mid = (L + R + 1) >> 1;\n            if(check(l, mid)) L = mid;\n            else R = mid - 1;\n        }\n        s ++, l = R;\n    }\n    cout << (n - s) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## E. Extracting Weights\n\n距离为 $k$ 的点对至多有 $\\mathcal{O}(n^2)$ 个，将每个看作是一个方程 $w_{u_0} \\oplus w_{u_1} \\oplus \\cdots \\oplus w_{u_k}=C$，，特别地，初始时给定了方程 $w_0=0$ ，只需要检验这些方程能否消元得到解。\n\n为此可以一个一个地将方程插入线性基，检验最后是否可以插入 $n-1$ 次（初始已经有方程 $w_0=0$），如果可行，就询问线性基中的这 $n-1$ 个方程，最后消元求解。总的时间复杂度为 $\\mathcal{O}(\\frac{n^4}{w})$。\n\n{% fold E. Extracting Weights 示例代码 %}\n```cpp E. Extracting Weights\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst int N = 256;\nint n, k; vector<int> G[N];\ntypedef bitset<N> bs;\n\nbool vis[N]; bs B[N], val[N]; int cnt = 0; pair<int, int> pr[N];\ninline void insert(bs M, pair<int, int> pr) {\n    if(cnt == n) return;\n    bs MM = M;\n    while(true) {\n        int i = M._Find_first();\n        if(i > n) break;\n        if(!vis[i]) {\n            vis[i] = true, B[i] = M, val[i] = MM, ::pr[i] = pr;\n            cnt ++; return;\n        } else M ^= B[i];\n    }\n}\nint anc;\nvoid dfs(int u, int fa, bs &M, int dep) {\n    M.flip(u);\n    if(dep == k) {\n        if(anc <= u) insert(M, {anc, u});\n        M.flip(u);\n        return;\n    }\n    for(int v : G[u]) {\n        if(v == fa) continue;\n        dfs(v, u, M, dep + 1);\n    }\n    M.flip(u);\n}\n\ninline void calc(vector<pair<bs, int>> &v) {\n    for(int i = 1; i < n; i ++) {\n        for(int j = 1; j <= i; j ++)\n            if(v[i].first[j]) {\n                v[i].first ^= v[j - 1].first;\n                v[i].second ^= v[j - 1].second;\n            }\n    }\n    for(int i = n - 2; i >= 0; i --) {\n        for(int j = n; j > i + 1; j --)\n            if(v[i].first[j]) {\n                v[i].first ^= v[j - 1].first;\n                v[i].second ^= v[j - 1].second;\n            }\n    }\n    for(int i = 0; i < n; i ++) {\n        v[i].first.flip(i+1);\n        assert(v[i].first.none());\n    }\n    cout << \"! \";\n    for(int i = 1; i < n; i ++) \n        cout << v[i].second << ' ';\n    cout << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    cin >> n >> k;\n    for(int i = 1; i < n; i ++) {\n        int a, b; cin >> a >> b;\n        G[a].emplace_back(b), G[b].emplace_back(a);\n    }\n    \n    bs a; a[1] = 1;\n    vis[1] = true, B[1] = val[1] = a, cnt ++;\n    bs M;\n    for(int i = 1; i <= n; i ++)\n        anc = i, dfs(i, 0, M, 0);\n    if(cnt == n) {\n        cout << \"YES\" << endl;\n        cout << \"? \" << n - 1 << ' ';\n        for(int i = 2; i <= n; i ++) \n            cout << pr[i].first << ' ' << pr[i].second << ' ';\n        cout << endl;\n        vector<int> ans(n + 1, 0);\n        for(int i = 2; i <= n; i ++)\n            cin >> ans[i];\n        vector<pair<bs, int>> vec(n);\n        for(int i = 1; i <= n; i ++)\n            vec[i - 1] = {val[i], ans[i]};\n        calc(vec);\n    } else cout << \"NO\" << endl;\n\n    return 0;\n}\n```\n{% endfold %}\n\n## G. GCD\n\n首先，答案一定不会超过 $26$，证明如下：\n\n假如两个数均为偶数，那么将它们同时除以 $2$，答案不变。\n\n否则，它们的 $\\mathrm{gcd}$ 是一个奇数，选定 $a,b$ 中的一个奇数，将它减去 $\\mathrm{gcd}$，我们就通过至多两次操作将 $a,b$ 全部变为了偶数。而 $a \\le 5000 < 2^{13}$，因此至多 $25$ 步就能将 $a$ 变为 $0$，此时若 $b \\ne 0$，则仅需一次操作即可将 $b$ 变为 $0$。\n\n因此直接爆搜即可，步骤大于 $26$ 就剪掉。\n\n{% fold G. GCD 示例代码 %}\n```cpp G. GCD\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint ans;\nvoid dfs(long long a, long long b, int c) {\n    if(a == 0 && b == 0) {\n        ans = min(ans, c);\n        return;\n    }\n    if(c > ans) return;\n    if(a) dfs(a - __gcd(a, b), b, c + 1);\n    if(b) dfs(a, b - __gcd(a, b), c + 1);\n}\n\ninline void solve() {\n    long long a, b;\n    cin >> a >> b;\n    ans = 26;\n    dfs(a, b, 0);\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## H. Horizon Scanning\n\n将所有点极角排序，求相隔 $k$ 个位置的极角差值的最大值即可，时间复杂度 $\\mathcal{O}(n \\log n)$，瓶颈在排序。\n\n{% fold H. Horizon Scanning 示例代码 %}\n```cpp H. Horizon Scanning\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nint n, k; double theta[N];\n\ninline void solve() {\n    cin >> n >> k;\n    for(int i = 1; i <= n; i ++) {\n        int x, y; cin >> x >> y;\n        theta[i] = atan2(y, x);\n    }\n    double ans = 0;\n    sort(theta + 1, theta + n + 1);\n    for(int i = 1; i <= n; i ++) {\n        if(i + k <= n)\n            ans = max(ans, theta[i + k] - theta[i]);\n        else\n            ans = max(ans, theta[i + k - n] -  theta[i] + acos(-1) * 2);\n    }\n    cout << fixed << setprecision(10) << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## J. Just another Sorting Problem\n\n- 如果 $n=2$，那么`Alice`必胜。\n\n- 否则 $n \\ge 3$，此时设位置不对的数有 $c$ 个\n    - 若 $c=2$，则谁先手谁获胜\n    - 否则，`Alice`获胜当且仅当 $n=3$ 且`Bob`先手，证明就是讨论一下`Bob`能否使得`Alice`在每次操作前都维持 $c \\ge 3$\n\n{% fold J. Just another Sorting Problem 示例代码 %}\n```cpp J. Just another Sorting Problem\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void solve() {\n    int n; string S;\n    cin >> n >> S;\n    int c = 0;\n    for(int i = 1; i <= n; i ++) {\n        int x; cin >> x;\n        if(x != i) c ++;\n    }\n    if(n >= 3) {\n        if(c == 2) cout << S << '\\n';\n        else if(n == 3) {\n            if(S == \"Alice\") cout << \"Bob\" << '\\n';\n            else cout << \"Alice\" << '\\n';\n        } else cout << \"Bob\" << '\\n';\n    } else cout << \"Alice\" << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## L. Last Chance: Threads of Despair\n\n设序列 $A$ 想要消灭序列 $B$，先用 $A$ 中不为 $1$ 的那些元素攻击 $B$ 中元素，最后一起爆炸一定最优。\n\n问题在于 $A$ 中那些不为 $1$ 的元素应该打谁：考虑将 $A,B$ 升序排序，维护当前最后可以连锁爆炸几次、还剩下多少刀可以打，每遇到一个最后解决不了的 $B$ 中元素就把它打到可以最后炸死的程度，然后让最后的爆炸次数加一。\n\n最后如果剩下一些刀（可以为 $0$）说明答案为`Yes`，否则为`No`。时间复杂度 $\\mathcal{O}(n \\log n + m \\log m)$，瓶颈在排序。\n\n{% fold L. Last Chance: Threads of Despair 示例代码 %}\n```cpp L. Last Chance: Threads of Despair\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5e5 + 10;\nint n, m, A[N], B[N];\n\ninline void solve() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i ++)\n        cin >> A[i];\n    for(int i = 1; i <= m; i ++)\n        cin >> B[i];\n    sort(A + 1, A + n + 1), sort(B + 1, B + m + 1);\n    long long c = n; int k = 0;\n    for(int i = 1; i <= n; i ++)\n        k += (A[i] == 1);\n    if(k) c -= (k - 1);\n    int i = 1, j = 1; while(i <= n && A[i] == 1) i ++;\n    for(int x = 1; x <= n; x ++) A[x] --;\n    while(j <= m && c >= 0) {\n        while(true) {\n            if((j > m || B[j] > k) && (i > n || A[i] > k)) break;\n            while(j <= m && B[j] <= k) k ++, j ++;\n            while(i <= n && A[i] <= k) k ++, i ++;\n        }\n        if(j <= m) \n            c -= (B[j] - k), B[j] = k;\n    }\n    cout << (c >= 0 ? \"Yes\" : \"No\") << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## M. Matrix Construction\n\n一种可能的构造方案是沿副对角线方向从小到大填入数字，例如：\n\n$$\n\\begin{pmatrix}\n1 &2 &4 &7\\\\\n3 &5 &8 &11\\\\\n6 &9 &12 &14\\\\\n10 &13 &15 &16\\\\\n\\end{pmatrix}\n$$\n\n证明：考虑相邻两个数一定在相邻的两个副对角线上，如果两对相邻的数（$a<b$ 和 $c<d$）所在的副对角线不同，那么由于处于左上方副对角线的元素一定更小，所以必然有\n\n- $a<c,b<d$\n- $c<a,d<b$\n\n中的一个成立，于是 $a+b \\ne c+d$ 自然成立\n如果位于相同的副对角线上，由于同一副对角线上元素是单调的，所以也不可能相等。\n\n{% fold M. Matrix Construction 示例代码 %}\n```cpp M. Matrix Construction\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void solve() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> A(n, vector<int>(m));\n    int k = 1;\n    for(int i = 0; i < m; i ++) \n        for(int j = 0; j <= i && j < n; j ++) \n            A[j][i - j] = k ++;\n    for(int i = 1; i < n; i ++) {\n        for(int d = 0; i + d < n && m - 1 - d >= 0; d ++)\n            A[i + d][m - 1 - d] = k ++;\n    }\n    cout << \"Yes\" << '\\n';\n    for(int i = 0; i < n; i ++)\n        for(int j = 0; j < m; j ++)\n            cout << A[i][j] << \" \\n\"[j == m - 1];\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n","tags":["ICPC","题解"],"categories":["OI"]},{"title":"高等代数学习笔记","url":"/post/77682b85.html","content":"\n高等代数学习笔记\n\n<!--more-->\n\n## 行列式\n\n### Laplace 定理\n\n#### k 阶子式\n\n对于 $n$ 阶行列式 ${\\boldsymbol{A}}$，选定 $k$ 行 $i_1 < i_2 < \\cdots < i_k$ 和 $k$ 列 $j_1 < j_2 < \\cdots < j_k$，它们的 $k^2$ 个交点按照原先的排列顺序组成一个新的 $k$ 阶行列式，叫做 ${\\boldsymbol{A}}$ 的一个 **$k$ 阶子式**，记作\n\n$$\n{\\boldsymbol{A}}\\begin{pmatrix}i_1,i_2,\\cdots ,i_k\\\\j_1,j_2,\\cdots ,j_k\\end{pmatrix}\n$$\n\n划去这 $k$ 行 $k$ 列，余下元素构成一个 $n-k$ 阶子式，叫做该 $k$ 阶子式的**余子式**，它乘上符号 $(-1)^{\\sum_{m=1}^{k}i_m+j_m}$ 称作该 $k$ 阶子式的**代数余子式**。\n\n#### Laplace 定理\n\n对于任一 $n$ 阶行列式 ${\\boldsymbol{A}}=(a_{ij})$，取定 $k$ 行 $i_1,i_2,\\cdots ,i_k$，$|{\\boldsymbol{A}}|$ 等于这 $k$ 行形成的所有子式与其代数余子式乘积的和，也即：\n\n$$\n|{\\boldsymbol{A}}|=\\sum_{1 \\le j_1 <\\cdots < j_k \\le n} {\\boldsymbol{A}}\\begin{pmatrix}i_1,i_2,\\cdots ,i_k\\\\j_1,j_2,\\cdots ,j_k\\end{pmatrix}(-1)^{\\sum_{m=1}^{k}i_m+j_m}{\\boldsymbol{A}}\\begin{pmatrix}i'_1,i'_2,\\cdots ,i'_{n-k}\\\\j'_1,j'_2,\\cdots ,j'_{n-k}\\end{pmatrix} \n$$\n\n其中 $\\{i'\\}$、$\\{j'\\}$ 分别为余子式的行号、列号（升序）。\n\n**证明：** 欲证 \n\n$$\n\\begin{aligned}\n|{\\boldsymbol{A}}|&=\\sum_{1 \\le j_1 < \\cdots < j_k \\le n} (-1)^{\\sum_{m=1}^{k}i_m+j_m}\\sum_{\\{u_k\\}} (-1)^{\\sigma(u)} a_{i_1u_1}\\cdots a_{i_ku_k}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(v)}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\\\\\n&=(-1)^{\\sum_{m=1}^{k}i_m}\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sum_{m=1}^{k}u_k}(-1)^{\\sigma(u)+\\sigma(v)}a_{i_1u_1}\\cdots a_{i_ku_k} a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}} \n\\end{aligned}\\tag{1}\n$$\n\n其中第一个等号处的序列 $u$ 为子式的列号 $j$ 的一个排列，将枚举 $\\{j\\}$ 再排列合并为一步：直接枚举 $1 \\sim n$ 的一个 $k$ 元排列 $\\{u\\}$，化至第二个等号；而对于序列 $v$，它枚举的是余子式的列号的排列。\n\n已知 \n\n$$\n|{\\boldsymbol{A}}|=\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(ii')+\\sigma(uv)}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n其中 $ii'$ 表示将序列 $i$、$i'$ 拼接起来得到的新序列，$uv$ 同理。\n\n欲证两式相等，先证一个引理：\n\n**引理1**：设 $a,b$ 为两个长度为 $n,m$ 的序列，序列中元素构成 $1 \\sim n+m$ 的一个排列，那么\n\n$$\n(-1)^{\\sigma(ab)}=(-1)^{\\sigma(a)+\\sigma(b)}(-1)^{\\left(\\sum_{i=1}^{n}a_i\\right)+\\frac{n(n+1)}{2}}\n$$\n\n**证明**：设将 $a$ 进行 $s$ 次对换可以使其升序排列为 $a'$，那么 $(-1)^{\\sigma(a)}=(-1)^s$，同时有\n\n$$\n(-1)^{\\sigma(ab)}=(-1)^s(-1)^{\\sigma(a'b)}\n$$\n\n考虑 $a'b$ 的逆序数，$a'_k$ 对于逆序数的贡献为 $a'_k-k$（比他小的数有 $a'_k-1$ 个，其中 $k-1$ 个在它之前），因此\n\n$$\n(-1)^{\\sigma(a'b)}=(-1)^{\\sum_{k=1}^{n}(a'_k-k)}(-1)^{\\sigma(b)}\n$$\n\n带回原式即可得到\n\n$$\n(-1)^{\\sigma(ab)}=(-1)^{\\sigma(a)+\\sigma(b)}(-1)^{\\left(\\sum_{k=1}^{n}a_k\\right)+\\frac{n(n+1)}{2}}\n$$\n\n证毕！\n\n回到原命题，已知\n\n$$\n|{\\boldsymbol{A}}|=\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(ii')+\\sigma(uv)}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n拆开 $(-1)^\\sigma$ 得到\n\n$$\n\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(i)+\\sigma(i')+\\sigma(u)+\\sigma(v)}(-1)^{\\sum_{m=1}^{k}i_k+u_k}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n而 $\\{i\\}$ 和 $\\{i'\\}$ 都是升序的，故 $\\sigma(i)=\\sigma(i')=0$，于是上式等于\n\n$$\n\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(u)+\\sigma(v)}(-1)^{\\sum_{m=1}^{k}i_k+u_k}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n这与式 $(1)$ 是一致的，证毕！\n\n#### 推论\n\n行列式可以分块计算，换句话说，\n\n$$\n\\begin{vmatrix}\n{\\boldsymbol{A}}&0\\\\\n{\\boldsymbol{B}}&{\\boldsymbol{C}}\n\\end{vmatrix}\n$$\n\n其中 ${\\boldsymbol{A}}$、${\\boldsymbol{B}}$、${\\boldsymbol{C}}$ 都是 $k$ 阶方阵，那么我们将它按照前 $k$ 行展开，子式不为零当且仅当恰取了前 $k$ 列，于是根据 Laplace 定理，\n\n$$\n\\begin{vmatrix}\n{\\boldsymbol{A}}&0\\\\\n{\\boldsymbol{B}}&{\\boldsymbol{C}}\n\\end{vmatrix}=|{\\boldsymbol{A}}|\\cdot |{\\boldsymbol{C}}|\n$$\n\n## 线性空间\n\n### 定义与性质\n\n设 $(V,+)$ 是一个 Abel 群，$\\mathbb{P}$ 是一个数域。定义 $\\mathbb{P}$ 与 $V$ 的一个代数运算数乘 $\\cdot$，运算结果仍然在 $V$ 中。\n\n令 $a,b \\in {\\mathbb{P}}$，$\\boldsymbol{u},\\boldsymbol{v} \\in V$，若满足：\n\n1. $\\cdot$ 对 $(V,+)$ 的分配律 $a\\cdot (\\boldsymbol{u}+\\boldsymbol{v})=a\\cdot\\boldsymbol{u}+a\\cdot\\boldsymbol{v}$\n2. 数乘对标量加法的分配律 $(a+b)\\cdot \\boldsymbol{u}=a \\cdot \\boldsymbol{u} + b \\cdot \\boldsymbol{u}$\n3. 数乘的结合律 $a(b\\boldsymbol{u})=(ab)\\boldsymbol{u}$\n4. 标量乘法具有单位元，令 $1 \\in {\\mathbb{P}}$ 是 $\\mathbb{P}$ 的单位元，则 $1\\boldsymbol{u}=\\boldsymbol{u}$\n\n则称代数系统 $(V,+,\\cdot ,{\\mathbb{P}})$ 是 $V$ 关于 $+,\\cdot$ 构成1 $\\mathbb{P}$ 上的一个**线性空间**，并称加法群中的零元为**零向量**，记作 $\\boldsymbol{0}$。\n\n任取 $\\boldsymbol{\\alpha_1},\\boldsymbol{\\alpha_2},\\cdots ,\\boldsymbol{\\alpha_n} \\in V$，那么 $U=\\{k_1\\boldsymbol{\\alpha_1}+k_2\\boldsymbol{\\alpha_2}+\\cdots +k_n\\boldsymbol{\\alpha_n} \\vert\\forall 1 \\le i \\le n, k_i \\in {\\mathbb{P}}\\}$ 构成一个子空间，我们将该子空间记作 $\\{ \\boldsymbol{\\alpha_1},\\boldsymbol{\\alpha_2},\\cdots ,\\boldsymbol{\\alpha_n} \\}$，于是可以将线性方程组看作如下形式：\n\n$$\n\\begin{pmatrix}a_{11}\\\\ a_{21}\\\\ \\vdots \\\\ a_{m1} \\end{pmatrix}x_1+\\begin{pmatrix}a_{12}\\\\ a_{22}\\\\ \\vdots \\\\ a_{m2} \\end{pmatrix}x_2+\\cdots +\\begin{pmatrix}a_{1n}\\\\ a_{2n}\\\\ \\vdots \\\\ a_{mn} \\end{pmatrix}x_n=\\begin{pmatrix}b_1\\\\ b_2\\\\ \\vdots \\\\ b_m \\end{pmatrix}\n$$\n\n于是我们其实就是在研究 向量 $\\boldsymbol{b}$ 是否在这 $n$ 个列向量 $\\boldsymbol{a_i}$ 张成的子空间内。\n\n### 线性相关与线性无关\n\n对于一个向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$，若存在不全为 $0$ 的数组 $k_1,\\cdots ,k_n$ 使得 \n\n$$\n\\sum_{i=1}^{n}k_i\\boldsymbol{\\alpha_i}=\\boldsymbol{0}\n$$\n\n则称这个向量组**线性相关**，否则称它**线性无关**。显然，只有零向量的向量组就是一个线性相关的向量组，任何含零向量的向量组必然线性相关。\n\n不加证明地给出如下结论（证明平凡）：\n\n**定理 1**：一个向量组线性无关当且仅当其中的任意一个向量不能被其余向量线性表出。\n\n**定理 2**：若 $\\boldsymbol{\\beta}$ 可以被一个向量组表出，则表出方式唯一等价于该向量组线性无关。\n\n**定理 3**：设向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$ 线性无关，则向量 $\\boldsymbol{\\beta}$ 可以被该向量组表出当且仅当向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}, \\boldsymbol{\\beta}$ 线性相关。\n\n**定理 4**：任意一个极大线性无关向量组张成的空间与原向量组张成的空间相同。\n\n**定义**：称两个线性空间相同当且仅当其可表出的向量相同，记作 $V_1 \\cong V_2$，其中 $V_1,V_2$ 为两个线性空间。\n\n### 向量组的秩\n\n**引理 1**：设 $n > m$，且向量组 $\\{ \\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n} \\}$ 可以被向量组 $\\{ \\boldsymbol{\\beta_1}, \\cdots ,\\boldsymbol{\\beta_m} \\}$ 线性表出，那么前者一定线性相关。\n\n**证明**：只需证 $x_1\\boldsymbol{\\alpha_1}+\\cdots +x_n\\boldsymbol{\\alpha_n}=\\boldsymbol{0}$ 有非零解，由已知，不妨设 $\\boldsymbol{\\alpha_k}=\\sum_{i=1}^{m}c_{ik}\\boldsymbol{\\beta_i}$，于是原式化为\n\n$$\n\\sum_{k=1}^{n}x_k\\sum_{i=1}^{m}c_{ik}\\boldsymbol{\\beta_i}=\\boldsymbol{0}\n$$\n\n整理得\n\n$$\n\\sum_{i=1}^{m}\\boldsymbol{\\beta_i}\\sum_{k=1}^{n}c_{ik}x_k=\\boldsymbol{0}\n$$\n\n要使上式成立，仅需 $\\sum_{k=1}^{n}c_{ik}x_k=0$ 对任意 $i$ 成立，问题归结为齐次线性方程组\n\n$$\n\\begin{cases}\nc_{11}x_1+c_{12}x_2+\\cdots +c_{1n}x_n=0\\\\\nc_{21}x_1+c_{22}x_2+\\cdots +c_{2n}x_n=0\\\\\n\\cdots \\\\\nc_{m1}x_1+c_{m2}x_2+\\cdots +c_{mn}x_n=0\\\\\n\\end{cases}\n$$\n\n是否有非零解，由于方程组个数 $m$ 小于未知数个数 $n$，所以这样的齐次线性方程组有无穷多组解，于是自然存在非零解，证毕！\n\n**推论 1**：考虑引理 1 的逆否命题，向量组 $\\{ \\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n} \\}$ 可以被向量组 $\\{ \\boldsymbol{\\beta_1}, \\cdots ,\\boldsymbol{\\beta_m} \\}$ 线性表出，若前者线性无关，则必然有 $n \\le m$。\n\n**推论 2**：等价的线性无关向量组中，向量的个数必然相同。\n\n**推论 3**：一个向量组的所有极大线性无关向量组中的向量个数相同。\n\n**定义**：由推论 3，我们可以得出**秩**的定义，一个向量组的秩就是其极大线性无关向量组中向量的个数，记作 $\\operatorname{rank} \\{ \\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n} \\}$。特别地，只含零向量的向量组的秩为 $0$。\n\n因此，向量组线性无关等价于其秩恰为其中向量个数，即 $\\operatorname{rank}\\{\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}\\}=n$。\n\n**推论 4**：若向量组 $\\boldsymbol{(I)}$ 可被向量组 $\\boldsymbol{(II)}$ 线性表出，则 $\\operatorname{rank} \\boldsymbol{(I)} \\le \\operatorname{rank} \\boldsymbol{(II)}$ \n\n**推论 5**：等价的向量组具有相等的秩。\n\n### 线性空间的基\n\n**定义**：对于线性空间 $V$，其有限子集 $V_0=\\{\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}\\}$ 线性无关当且仅当向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$ 线性无关；其无限子集 $S$ 线性无关当且仅当 $S$ 的所有有限子集均线性无关。\n\n**定义**：设 $V$ 是一个线性空间，若其子集 $S$ 满足：\n\n- $S$ 线性无关\n- $V$ 中任一向量均可被 $S$ 线性表出\n\n则称 $S$ 是 $V$ 的一个**基**。特别地，定义空基线性无关，于是只含零向量的线性空间的一个基为空基。\n\n**定理 5**：任一数域上的任一线性空间都有一个基。\n\n证明略去。\n\n**定义**：若 $V$ 存在一个基是有限子集，则称 $V$ 是有限维的；若 $V$ 存在一个基是无限子集，则称 $V$ 是无限维的。\n\n**定理 6**：若 $V$ 是有限维的，则它的所有基中的向量个数相同。\n\n**推论 6**：无限维的线性空间的基都是无限集。\n\n**定义**：假设 $V$ 是有限维的线性空间，称其任一基中所含的向量个数称为 $V$ 的**维数**，记作 $\\operatorname{dim} V$ 或 $\\operatorname{dim}_{\\mathbb{P}} V$，其中 $\\mathbb{P}$ 为数域。若 $V$ 是无限维的空间，则称 $\\operatorname{dim} V=\\infty$。特别地，只含零向量的线性空间的维数为 $0$。\n\n**定义**：设 $\\operatorname{dim} V=n$，则取 $V$ 的一个基 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$，$V$ 中的任一向量 $\\boldsymbol{\\beta}$ 都能被唯一地表示为 $\\boldsymbol{\\beta}=\\sum_{k=1}^{n}c_k\\boldsymbol{\\alpha_k}$，此时称 $\\boldsymbol{\\beta}$ 的**坐标**为 $\\begin{pmatrix}c_1\\\\c_2\\\\ \\vdots \\\\ c_n\\end{pmatrix}$。","tags":["学习笔记","高等代数"],"categories":["数学"]},{"title":"Pell 方程","url":"/post/9861dc77.html","content":"\n内容基本来源于 [OI-wiki](https://oi-wiki.org/math/number-theory/pell-equation)\n\n<!--more-->\n\n## 定义与结构\n\n（广义）Pell 方程指关于 $x,y$ 的不定方程 \n\n$$\nx^2-Dy^2=C\n$$\n\n当 $D\\le 0$ 或为完全平方数时是平凡的，我们不予考虑，同时，解 $(\\pm 1,0)$ 也是平凡的，接下来的讨论中忽略该解。而狭义的 Pell 方程专指 $C=1$ 或 $C=\\pm 1$ 的特殊情况。\n\n对于一个二次整数 $x+y\\sqrt D$（它是一个二次方程的根），定义其范数为它与它的共轭的积，记为\n\n$$\nN(x+y\\sqrt D)=x^2-Dy^2\n$$\n\n所以，广义 Pell 方程大致相当于在求解范数为 $C$ 的二次整数，但并不等价，因为二次整数形如 $\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$，当 $D \\equiv 1 \\pmod 4$ 时， $x,y$ 可以同时为半整数。\n\n范数具有一些性质，这对 Pell 方程的求解至关重要。\n\n**Brahmagupta 恒等式** \n\n$$\n(x_1^2-Dy_1^2)(x_2^2-Dy_2^2)=(x_1x_2+Dy_1y_2)^2-D(x_1y_2+x_2y_1)^2\n$$\n\n证明显然。这说明了什么？这说明二次整数的范数保持乘法，也即\n\n$$\nN(x_1+y_1 \\sqrt D) \\cdot N(x_2+y_2 \\sqrt D)=N\\Big( (x_1+y_1\\sqrt D)(x_2+y_2\\sqrt D) \\Big)\n$$\n\n利用这个性质，假如我们知道了 $x^2-Dy^2=N_1$ 的一组解和 $x^2-Dy^2=N_2$ 的一组解，我们就能立刻写出 $x^2-Dy^2=N_1N_2$ 的一组解。正因 Pell 方程的解和二次整数的紧密联系，我们将解 $(x,y)$ 直接写成 $x+y\\sqrt D$ 的形式。\n\n同时，由于 Pell 方程表示的是一个双曲线的方程，所以我们只需要找到第一象限的所有解即可。\n\n在下文中，我们只探讨狭义 Pell 方程的求解，文章开头的链接中给出了广义 Pell 方程的求解方式，但这里暂时不作延申。\n\n## 狭义 Pell 方程的求解\n\n由上文可知，如果存在一个解 $x_1+y_1\\sqrt D$，那么所有 $(x_k+y_k \\sqrt D)=(x_1+y_1\\sqrt D)^k$ 都将是 Pell 方程的解（范数的积性），我们先声称存在一个基本解（使 $x_1+y_1\\sqrt D$ 最小的 $(x_1,y_1)$），下面证明它的 $k$ 次幂 $x_k+y_k \\sqrt D$ 可以得到所有解。\n\n不妨设第一象限中存在一个另外的解 $x_k+y_k\\sqrt D < x+y\\sqrt D < x_{k+1}+y_{k+1}\\sqrt D$，两侧同时乘 $x_k-y_k\\sqrt D$ 得到\n\n$$\n1 < (xx_k-Dyy_k)+(x_ky-xy_k)\\sqrt D < x_1+y_1\\sqrt D\n$$\n\n这与 $x_1+y_1 \\sqrt D$ 最小矛盾！\n\n下面，我们给出 Pell 方程基本解的构造性证明。\n\n### PQa 算法\n\nPQa 算法可以得出特定的二次无理数的连分数展开。设整数 $P_0,Q_0,D$ 满足 $Q_0 \\ne 0$，$D > 0$ 且不是完全平方数，且 $P_0^2 \\equiv D \\pmod {Q_0}$，那么二次无理数\n\n$$\n\\omega=\\frac{P_0+\\sqrt D}{Q_0}\n$$\n\n的连分数展开 $[a_0,a_1,\\cdots]$ 可以由如下递推求得：\n\n$$\n\\begin{cases}\na_k=\\left\\lfloor \\frac{P_k+\\sqrt D}{Q_k} \\right\\rfloor\\\\\nP_{k+1}=a_kQ_k-P_k\\\\\nQ_{k+1}=\\frac{D-P_{k+1}^2}{Q_k}\n\\end{cases}\n$$\n\n进而， $\\omega$ 的第 $k$ 个渐进分数的分子和分母 $A_k$ 和 $B_k$ 由如下递推给出：\n\n$$\n\\begin{cases}\nA_k=a_kA_{k-1}+A_{k-2}\\\\\nB_k=a_kB_{k-1}+B_{k-2}\n\\end{cases}\n$$\n\n其中 $A_{-1}=1$，$A_{-2}=0$，$B_{-1}=0$，$B_{-2}=1$\n\n证明可以参见 [OI-wiki](https://oi-wiki.org/math/number-theory/continued-fraction/)，也可以看 [ProjectEuler板刷记录](https://la-syh.blog/post/7399281c.html) 中的`Problem 64`。\n\n记 $\\omega = [a_0,\\cdots ,a_{k_0-1},\\overline{a_{k_0},\\cdots ,a_{k_0+l-1}}]$，下面我们利用 PQa 算法解决 Pell 方程。\n\n::: {.theorem .unnumbered#定理}\n设 $G_k=Q_0A_k-P_0B_k$，则整数对 $(G_{k-1},B_{k-1})$ 满足 \n\n$$\nG_{k-1}^2-DB_{k-1}^2=(-1)^kQ_0Q_k\n$$\n\n且它们的最大公因数 $\\operatorname{gcd}(G_{k-1},B_{k-1})$ 整除 $Q_k$\n:::","tags":["学习笔记","数论"],"categories":["数学"]},{"title":"ProjectEuler板刷记录","url":"/post/7399281c.html","content":"\n本文收录一些[ProjectEuler](https://projecteuler.net/)中有趣的题目并给出个人题解。\n\n<!--more-->\n\n**[Problem 54](https://projecteuler.net/problem=54)**\n\n本题并不困难，只是一个简单的模拟，但是如何让代码量减小是一个值得讨论的问题。\n\n首先，我们可以将牌的点数和花色分开存储，我们只关心“所有牌的花色是否均相同”而不关注“每个牌的花色是多少”，所以可以分别排序。\n\n之后，写一个函数level(card, color)来返回手牌的等级（数字越大，等级越高），若两人等级不同则直接判断，否则需要进一步比较具体点数。\n\n这里是减少代码量的关键一步：不必对每一个等级都写一个具体的比较，注意到只有`Flush`的比较策略是不同的：每次拿剩下的最大手牌比较。\n\n对于剩下的等级，我们只需对每个玩家存储：对每个k，出现过k次的牌的点数是什么。之后，依次比较出现过4次、3次、2次、1次的牌的点数大小即可。\n\n{% fold Problem 54 示例代码 %}\n```py Problem 54\nwith open('0054_poker.txt', 'r') as file:\n    content = file.readlines()\n\nans = 0\ndef init(str):\n    if ord(str[0]) >= ord('2') and ord(str[0]) <= ord('9'):\n        return ord(str[0]) - ord('0')\n    if str[0] == 'T':\n        return 10\n    if str[0] == 'J':\n        return 11\n    if str[0] == 'Q':\n        return 12\n    if str[0] == 'K':\n        return 13\n    if str[0] == 'A':\n        return 14\n    return -1\ndef level(card, color):\n    straight = True\n    for k in range(1, 5):\n        if card[k] != card[k - 1] + 1:\n            straight = False\n    if color[0] == color[4]:\n        if straight and card[0] == 10:\n            return 10\n        elif straight:\n            return 9\n    if card[0] == card[3] or card[1] == card[4]:\n        return 8\n    if (card[0] == card[2] and card[3] == card[4]) or (card[0] == card[1] and card[2] == card[4]):\n        return 7\n    if color[0] == color[4]:\n        return 6\n    if straight:\n        return 5\n    if card[0] == card[2] or card[1] == card[3] or card[2] == card[4]:\n        return 4\n    pairs_count = 0\n    k = 0\n    while k < 4:\n        if card[k] == card[k + 1]:\n            pairs_count += 1\n            k += 1\n        k += 1\n    if pairs_count == 2:\n        return 3\n    if pairs_count == 1:\n        return 2\n    return 1\ndef beat(Alice, Bob):\n    level_Alice = level(Alice[0], Alice[1])\n    level_Bob = level(Bob[0], Bob[1])\n    if level_Alice != level_Bob:\n        return level_Alice > level_Bob\n    if level_Alice == 6:\n        k = 4\n        while True:\n            if Alice[0][k] != Bob[0][k]:\n                return Alice[0][k] > Bob[0][k]\n            k -= 1\n    A = [[], [], [], [], []]\n    B = [[], [], [], [], []]\n    for k in range(2, 15):\n        A[Alice[0].count(k)].append(k)\n        B[Bob[0].count(k)].append(k)\n    for k in range(1, 5):\n        A[k].sort(reverse = True)\n        B[k].sort(reverse = True)\n    k = 4\n    while True:\n        for i in range(len(A[k])):\n            if A[k][i] != B[k][i]:\n                return A[k][i] > B[k][i]\n        k -= 1\ndef work(arr):\n    global ans\n    arr = arr.split()\n    Alice = [[init(arr[k]) for k in range(0, 5)], [arr[k][1] for k in range(0, 5)]]\n    Bob = [[init(arr[k]) for k in range(5, 10)], [arr[k][1] for k in range(5, 10)]]\n    for k in range(0, 2):\n        Alice[k].sort()\n        Bob[k].sort()\n    # print(Alice)\n    # print(Bob)\n    if beat(Alice, Bob):\n        ans += 1\nfor line in content:\n    work(line)\nprint(ans)\n```\n{% endfold %}\n\n**[Problem 59](https://projecteuler.net/problem=59)**\n\n简单有趣的一道题。可以通过字母频率分析猜一猜密钥，如果懒得做的话可以像我一样直接枚举。\n\n得到所有可能的原文章后，我们要筛选出有意义的那一个，当然不能一个一个去看，可以在Sublime Text里搜索几个常见词汇，比如我搜索了` the `（两侧带空格），直接可以得到密钥是`exp`，问题就结束了。\n\n{% fold Problem 59 代码 %}\n```py 得到所有可能的原串\ntext = []   # 填入所给文件内容\nkey = [0, 0, 0]\ndef work():\n    id = 0\n    T = text.copy()\n    for i in range(len(T)):\n        T[i] = chr(T[i] ^ key[id])\n        id += 1\n        if id == 3:\n            id = 0\n    str = ''\n    for c in T:\n        str += c\n    with open('output.txt', 'a') as f:\n        for k in range(0, 3):\n            f.write(chr(key[k]))\n        f.write('\\n')\n        f.write(str)\n        f.write('\\n')\nfor a in range(ord('a'), ord('z') + 1):\n    key[0] = a\n    for b in range(ord('a'), ord('z') + 1):\n        key[1] = b\n        for c in range(ord('a'), ord('z') + 1):\n            key[2] = c\n            work()\n```\n\n```py 已知密钥求答案\ntext = []   # 填入所给文件内容\nkey = [ord('e'), ord('x'), ord('p')]\nid = 0\nfor i in range(len(text)):\n    text[i] = text[i] ^ key[id]\n    id += 1\n    if id == 3:\n        id = 0\nans = 0\nfor x in text:\n    ans += x\nprint(ans)\n```\n{% endfold %}\n\n**[Problem 60](https://projecteuler.net/problem=60)**\n\n本题是前60道题中难度最大的一道，但是也比较常规。\n\n考虑转化到图论上。如果两个素数的拼接仍然是素数，就在它们之间连边，要求的就是数字和最小的 $K_5$ 子图。这种东西就直接爆搜，远远跑不满五次方的上界，可以在 $8$ 秒内跑出结果，如果用某些工程库的求 $K_5$ 子图模板可以更快，但没必要。\n\n本题中如果没有提前建好图，而是在爆搜过程中不断调用`isprime`会巨慢无比，什么东西都跑不出来，笔者最开始就是因为这个卡住了。\n\n{% fold Problem 60 示例代码 %}\n```py Problem 60\nimport math\nimport time\nimport sympy\nSTART = time.time()\n\nN = int(1e6) + 10\nd = [0] * N\nprimes = []\ndef Sieve(n):\n    d[1] = 1\n    for i in range(2, n + 1):\n        if d[i] == 0:\n            d[i] = i\n            primes.append(i)\n        for x in primes:\n            if x * i > n:\n                break\n            d[x * i] = x\n            if(i % x == 0):\n                break\nSieve(int(1e4))\ndef check(a, b):\n    return sympy.isprime(int(str(a) + str(b))) and sympy.isprime(int(str(b) + str(a)))\nedges = [[] for _ in range(len(primes))]\nfor i in range(len(primes)):\n    for j in range(i + 1, len(primes)):\n        if check(primes[i], primes[j]):\n            edges[i].append(j)\n            edges[j].append(i)\nprint('Total nodes:', len(primes))\n\nans = int(1e18)\nval = [0, 0, 0, 0, 0]\ndef dfs(dep):\n    global ans, val\n    if dep == 5:\n        S = 0\n        for k in range(5):\n            S += primes[val[k]]\n        print(val)\n        ans = min(ans, S)\n        print(ans)\n        return\n    for i in range(len(primes)):\n        if primes[i] == 5:\n            continue\n        if dep != 0 and i <= val[dep - 1]:\n            continue\n        val[dep] = i\n        flag = True\n        for j in range(0, dep):\n            if not edges[i].count(val[j]):\n                flag = False\n                break\n        if flag:\n            dfs(dep + 1)\ndfs(0)\nprint('Result =', ans)\n\nEND = time.time()\nprint(f\"耗时:{END - START:.4f}秒\")\n```\n{% endfold %}\n\n**[Problem 64](https://projecteuler.net/problem=64)**\n\n以连分数为背景的一道题，正好来学习一下相关内容。\n\n定理：所有循环连分数都是二次无理数，且任何一个二次无理数都可以写成循环连分数的形式。\n\n证明：先证明所有循环连分数都是二次无理数。对于一般的循环连分数 $x=[a_0,\\cdots, a_{k-1},\\overline{a_k,\\cdots ,a_{k+L+1}}]$，设 $y=[\\overline{a_k, \\cdots, a_{k+L+1}}]$，则\n\n$$\n\\begin{aligned}\n&x=[a_0,\\cdots, a_{k-1},\\overline{a_k,\\cdots ,a_{k+L+1}}]=L_0(y)\\\\\n&y=[\\overline{a_k, \\cdots, a_{k+L+1}}]=L_1(y)\n\\end{aligned}\n$$\n\n其中 $L_0$ 和 $L_1$ 都是分式线性变换，于是得到\n\n$$\nx=L_0 \\circ L_1 \\circ L_0^{-1}(x)\n$$\n\n右侧的复合仍然是一个分式线性变换，不妨设\n\n$$\nL_0 \\circ L_1 \\circ L_0^{-1}(x)=\\frac{ax+b}{cx+d}\n$$\n\n则得到关于 $x$ 的方程 $cx^2+(d-a)x-b=0$，因此循环连分数都是整系数二次方程的解，又因为无线连分数都是无理数，因此循环连分数表示了二次无理数。\n\n接下来，我们证明任意二次无理数都可以写成循环连分数，这是对于本题重要的一步，因为我们可以通过这个过程得到计算连分数形式的算法。\n\n首先，二次无理数总可以表示成 $x=\\frac{P_0+\\sqrt D}{Q_0}$ 的形式，其中 $P_0,Q_0,D$ 都是整数且 $Q_0 | D-P_0^2$。证明很容易，$\\frac{p_a}{q_a}+\\frac{p_b}{q_b}\\sqrt{D'}$可以通分为\n\n$$\n\\frac{p_ap_bq_aq_b+\\sqrt{(q_aq_b)^2D'}}{(q_aq_b)^2}\n$$\n\n令 $P=p_ap_bq_aq_b$，$Q=(q_aq_b)^2$，$D=QD'$ 即可。\n\n为什么要写成这样的形式？因为它的所有余项都有类似的形式：\n\n$$\nr_k=\\frac{P_k+\\sqrt{D}}{Q_k}\n$$\n\n其中 $P_k$，$Q_k$ 是整数并且 $Q_k | D-P_k^2$。其中，条件 $Q_k | D-P_k^2$保证了所有余项的分子中，$\\sqrt D$ 前面的系数都是 $1$。\n\n数学归纳求 $P_k$，$Q_k$ 的形式：设 $a_k=\\left\\lfloor r_k \\right\\rfloor$，那么 $r_k=a_k+\\frac{1}{r_{k+1}}$。\n\n设 $r_{k+1}$ 也有类似形式，带入得到\n\n$$\n\\frac{P_k+\\sqrt D}{Q_k}=a_k+\\frac{Q_{k+1}}{P_{k+1}+ \\sqrt D}=a_k+\\frac{Q_{k+1}P_{k+1}-Q_{k+1}\\sqrt D}{P_{k+1}^2-D}\n$$\n\n对比系数可得\n\n$$\n\\begin{cases}\nP_{k+1}=a_kQ_k-P_k\\\\\nQ_{k+1}=-a_k^2Q_k+2a_kP_k+\\frac{D-P_k^2}{Q_k}\n\\end{cases}\n$$\n\n实际应用时，可以用更简便的 $Q_{k+1}=\\frac{D-P_{k+1}^2}{Q_k}$\n\n根据 $Q_k | D-P_k^2$，所以 $P_{k+1}$ 和 $Q_{k+1}$ 确实都是整数，即 $r_{k+1}$ 确实具有要求的形式。\n\n到此，我们已经得到了求二次无理数的连分数形式的算法，下面证明余项只能取到有限多个值，因此必然存在循环节。\n\n已经求得余项为\n\n$$\n\\frac{P_k+\\sqrt D}{Q_k}=r_k=-\\frac{q_{k-2}x-p_{k-2}}{q_{k-1}x-p_{k-1}}\n$$\n\n对于无理数，总有 $r_k>1$，同时，其共轭 \n\n$$\nr_k^*=-\\frac{q_{k-2}}{q_{k-1}}\\frac{x^*-\\frac{p_{k-2}}{q_{k-2}}}{x^*-\\frac{p_{k-1}}{q_{k-1}}}\n$$\n\n因为 $q_{k-2}/q_{k-1}>0$ 并且 \n\n$$\n\\lim_{k \\to \\infty} \\frac{x^*-\\frac{p_{k-2}}{q_{k-2}}}{x^*-\\frac{p_{k-1}}{q_{k-1}}}=\\frac{x^*-x}{x^*-x}=1\n$$\n\n因此对充分大的 $k$，必然有 $r_k^*<0$，因此 \n\n$$\n\\frac{2\\sqrt D}{Q_k}=r_k-r_k^*>1\n$$\n\n得到\n\n$0 < Q_k \\le 2\\sqrt D$，因此 $Q_k$ 只能取有限个值，进一步由递推公式，$P_k$ 也只能取有限个值，证毕。\n\n代码就根据上面的递推写就行了，没什么难度。这里直接用了[OI-wiki](https://oi-wiki.org/math/number-theory/continued-fraction/#__tabbed_8_2)的实现。\n\n{% fold Problem 64 代码 %}\n```py Problem 64\n# Return the continued fraction and minimal positive period\n#   of a quadratic irrational (x + y * sqrt(n)) / z.\nimport math\ndef quadratic_irrational(x, y, z, n):\n    p = x * z\n    d = n * y * y * z * z\n    q = z * z\n    dd = math.floor(math.sqrt(n)) * y * z\n    i = 0\n    a = []\n    used = dict()\n    while (p, q) not in used:\n        a.append((p + dd) // q)\n        used[p, q] = i\n        p = a[-1] * q - p\n        q = (d - p * p) // q\n        i += 1\n    return a, i - used[p, q]\n\nans = 0\nfor k in range(1, 10000 + 1):\n    if int(math.sqrt(k)) ** 2 == k:\n        continue\n    if quadratic_irrational(0, 1, 1, k)[1] % 2 == 1:\n        ans += 1\nprint(ans)\n```\n{% endfold %}","tags":["习题"],"categories":["数学"]},{"title":"Machine Learning","url":"/post/c5317df1.html","tags":["学习笔记"]},{"title":"高等数学学习笔记","url":"/post/4fc449fa.html","content":"\n本文仅摘录一些概念，内容主要来自同济《高等数学》（第八版），更多题目会在别的文章中.\n\n本文不会过多展示网络上可以广泛寻找到的证明内容.\n<!--more-->\n\n## 极限，连续性\n\n**极限存在准则I（数列）** 如果数列 $x,y,z$ 满足\n\n- $\\exists n_0 \\in \\mathbb{N}_+$，当$n>n_0$ 时有 $y_n\\le x_n \\le z_n$\n\n- $\\lim y_n=\\lim z_n = A$\n\n那么数列 $\\{x_n\\}$ 的极限存在且等于 $A$.\n\n**极限存在准则I'（函数）** 如果\n\n- 当 $x \\in \\overset{\\circ}{U}(x_0,r)$（或$|x|>M$）时，$g(x)\\le f(x)\\le h(x)$ \n\n- $\\lim g(x)=\\lim h(x)=A$\n\n那么 $\\lim f(x)$ 存在且等于 $A$.\n\n**准则II** 单调有界数列必有极限\n\n**准则II'** 设函数 $f(x)$ 在点 $x_0$ 的某个左邻域内单调且有界，则 $f(x)$ 在 $x_0$ 的左极限必定存在.\n\n**Cauchy 极限存在准则** 数列 $\\{x_n\\}$ 收敛的充分必要条件是：对于任意给定的正数 $\\varepsilon$ ，存在正整数 $N$ 使得当 $n,m>N$ 时有 $|x_n-x_m|<\\varepsilon$  \n\n同济《高等数学》中避开了对充分性的证明，事实上可以用 Bolzano-Weierstrass 定理‌证.\n\n**Bolzano-Weierstrass 定理‌** 有界数列必有一个收敛子列.\n\n欲证Bolzano-Weierstrass 定理‌，仅需证一个叫Peak point lemma的引理.\n\n**Peak point lemma** 任意数列都具有一个单调递增或单调递减的子列.\n$$\n(1+x)^n \\sim 1+nx(x \\to 0)\n$$\n习题1-6.4：利用极限存在准则证明 \n$$\n(2)\\lim_{n \\to \\infty}\\sum_{k=1}^{n}\\frac{1}{n+\\frac{k\\pi}{n}}=1\\\\\n(4)\\lim_{x \\to 0^+} x\\left\\lfloor\\frac{1}{x} \\right\\rfloor=1\n$$\n (2) 考虑 $n<n+\\frac{k\\pi}{n}\\le n+\\pi$，(4) 考虑 $t-1<\\left\\lfloor t \\right\\rfloor\\le t$.\n\n**连续** 设函数 $y=f(x)$ 在点 $x_0$ 的某一邻域内有定义，如果 \n$$\n\\lim_{\\Delta x \\to 0} \\Delta y=\\lim_{\\Delta x \\to 0} [f(x_0+\\Delta x) - f(x_0)]=0\n$$\n那么就称函数 $y=f(x)$ 在点 $x_0$ 连续.\n\n上式还等价于 \n$$\n\\lim_{x\\to x_0} f(x)=f(x_0)\n$$\n对于左（右）连续，将极限换为左（右）极限即可.\n\n习题1-8.8：$f(x)$ 是定义域为 $\\mathbb R$ 的线性函数，且 $f(x)$ 在$x=0$ 处连续，则它在 $\\mathbb R$ 上连续.\n\n**一致连续** 设函数 $f(x)$ 在区间 $I$ 上有定义.如果对于任意给定的正数 $\\varepsilon$，总存在正数 $\\delta$，使得对于区间 $I$ 上的任意两点 $x_1,x_2$，当 $|x_1-x_2|<\\delta$ 时，有 $|f(x_1)-f(x_2)|<\\varepsilon$，那么称函数 $f(x)$ 在区间 $I$ 上一致连续.\n\n**一致连续性定理** 如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，那么它在该区间上一致连续.\n\n 习题1-10.9：在什么条件下，$(a,b)$ 内的连续函数 $f(x)$ 一致连续？\n\n充要条件：$\\lim_{x \\to a^+} f(x)$ 和 $\\lim_{x \\to b^-} f(x)$ 均存在\n\n## 导数，微分\n\n习题2-1.4：设函数 \n\n$$\nf(x)=\\frac{(x-1)(x-2)\\cdots (x-n)}{(x+1)(x+2)\\cdots (x+n)}\n$$\n\n求 $f'(1)$.\n\n直接求导有点抽象，对数求导出来也要算一个极限，那就试试直接按定义做. $f(1)=0$，于是\n\n$$\n\\lim_{h \\to 0} \\frac{f(1+h)-f(1)}{h}=\\lim_{h \\to 0} \\frac{f(1+h)}{h}=\\lim_{h \\to 0}\\frac{1}{h}\\cdot \\frac{h(h-1)\\cdots (h-n+1)}{(h+2)(h+3)\\cdots (h+n+1)}\n$$\n\n于是 \n\n$$\nf'(1)=\\lim_{h \\to 0} \\frac{(h-1)\\cdots (h-n+1)}{(h+2)\\cdots (h+n+1)}=(-1)^{n-1}\\frac{(n-1)!}{(n+1)!}=\\frac{(-1)^{n-1}}{n(n+1)}\n$$\n\n**微分** 设函数 $y=f(x)$ 在某区间内有定义，$x_0$ 及 $x_0+\\Delta x$ 在这区间内，如果函数的增量 $\\Delta y=f(x_0+\\Delta x)-f(x_0)$ 可表示为\n\n$$\n\\Delta y=A\\Delta x+o(\\Delta x)\n$$\n\n其中 $A$ 是不依赖于 $\\Delta x$ 的常数，那么称函数 $y=f(x)$ 在点 $x_0$ 是可微的，而 $A\\Delta x$ 叫做函数 $y=f(x)$ 在点 $x_0$ 相应于自变量增量 $\\Delta x$ 的微分，记作 ${\\rm d} y$，即 ${\\rm d} y=A\\Delta x$.\n\n### 微分中值定理\n\n**Fermat 引理** 设函数 $f(x)$ 在点 $x_0$ 的某邻域 $U(x_0)$ 内有定义，并且在 $x_0$ 处可导，如果对任意的 $x \\in U(x_0)$，有 $f(x) \\le f(x_0)$（或 $f(x) \\ge f(x_0)$），那么 $f'(x_0)=0$.\n\n**Rolle 定理** 如果函数 $f(x)$ 满足\n\n- 在闭区间 $[a,b]$ 上连续\n- 在开区间 $(a,b)$ 上可导\n- 在区间端点处的函数值相等，即 $f(a)=f(b)$\n\n那么在 $(a,b)$ 内至少有一点 $\\xi$ 使得 $f'(\\xi)=0$.\n\n**Lagrange 中值定理** 如果函数 $f(x)$ 满足 \n\n- 在闭区间 $[a,b]$ 连续\n- 在开区间 $(a,b)$ 内可导\n\n那么在 $(a,b)$ 上至少有一点 $\\xi$ 满足 $f'(\\xi)=\\frac{f(b)-f(a)}{b-a}$.\n\n**Cauchy 中值定理** 如果函数 $f(x)$ 与 $F(x)$ 满足\n\n- 在闭区间 $[a,b]$ 上连续\n- 在开区间 $(a,b)$ 内可导\n- 对任一 $x \\in (a,b),F'(x) \\ne 0$\n\n那么在 $(a,b)$ 内至少有一点 $\\xi$ 使等式\n\n$$\n\\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{f'(\\xi)}{F'(\\xi)}\n$$\n\n成立.\n\n### 洛必达（L'Hospital）法则\n\n**定理1** 设\n\n- 当 $x \\to a$ 时，函数 $f(x)$ 和 $F(x)$ 都趋于 $0$.\n- 在点 $a$ 的某去心邻域内，$f'(x)$ 及 $F'(x)$ 都存在且 $F'(x) \\ne 0$.\n- $\\displaystyle\\lim_{x \\to a} \\frac{f'(x)}{F'(x)}$ 存在或为无穷大\n\n则\n\n$$\n\\lim_{x \\to a}\\frac{f(x)}{F(x)}=\\lim_{x \\to a}\\frac{f'(x)}{F'(x)}\n$$\n\n**定理2** 设\n\n- 当 $x \\to \\infty$ 时，函数 $f(x)$ 及 $F(x)$ 都趋于 $0$.\n- 当 $|x|>N$ 时 $f'(x)$ 与 $F'(x)$ 都存在且 $F'(x) \\ne 0$.\n- $\\displaystyle\\lim_{x \\to \\infty} \\frac{f'(x)}{F'(x)}$ 存在或为无穷大.\n\n则 \n\n$$\n\\lim_{x \\to \\infty} \\frac{f(x)}{F(x)}=\\lim_{x \\to \\infty} \\frac{f'(x)}{F'(x)}\n$$\n\n## Taylor 展开\n\n**Taylor 中值定理1** 如果函数 $f(x)$ 在 $x_0$ 处具有 $n$ 阶导数，那么存在 $x_0$ 的一个邻域，对于该邻域内的任一 $x$，有\n\n$$\nf(x)=R_n(x)+\\sum_{k=0}^{n}\\frac{f^{(k)}(x_0)}{k!}(x-x_0)^n\n$$\n\n其中\n\n$$\nR_n(x)=o((x-x_0)^n)\n$$\n\n此为带Peano余项的 $n$ 阶 Taylor 公式.\n\n**Taylor 中值定理2** 如果函数 $f(x)$ 在 $x_0$ 的某个邻域 $U(x_0)$ 内具有 $n+1$ 阶导数，那么对任一 $x \\in U(x_0)$ 有\n\n$$\nf(x)=R_n(x)+\\sum_{k=1}^{n}\\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k\n$$\n\n其中 \n\n$$\nR_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}\n$$\n\n这里 $\\xi$ 是 $x_0$ 与 $x$ 之间的某个值，此为带 Lagrange 余项的 $n$ 阶 Taylor 公式.\n\n习题3-3.10 \n\n(1) 求 $\\displaystyle\\lim_{x \\to +\\infty}\\left( \\sqrt[3]{x^3+3x^2}-\\sqrt[4]{x^4-2x^3} \\right)$\n\n考虑将原式化为\n\n$$\n\\lim_{x \\to +\\infty}x\\left( \\sqrt[3]{1+\\frac{3}{x}}-\\sqrt[4]{1-\\frac{2}{x}} \\right)\n$$\n\n根据 Taylor 公式，$\\sqrt[3]{1+\\frac{3}{x}}=1+\\frac{1}{x}+o(\\frac{1}{x})$，同时 $\\sqrt[4]{1-\\frac{2}{x}}=1-\\frac{1}{2x}+o(\\frac{1}{x})$\n\n于是原极限等于\n\n$$\n\\lim_{x \\to \\infty} x\\left( \\frac{3}{2x}+o\\left(\\frac{1}{x}\\right) \\right)=\\lim_{x \\to \\infty} \\left( \\frac{3}{2}+\\frac{o(1/x)}{1/x} \\right)=\\frac{3}{2}\n$$\n\n习题3-3.11\n\n若函数 $f(x)$ 在 $\\mathbb R$ 上有二阶导数，且 $f''(x)>0$，还有 $\\displaystyle\\lim_{x \\to 0}\\frac{f(x)}{x}=1$.证明：$f(x) \\ge x$.\n\n证明：$f(x)$ 连续，故 $f(0)=\\displaystyle\\lim_{x \\to 0} \\frac{f(x)}{x} \\cdot x=1 \\times 0 = 0$\n\n并且 $f'(0)=\\displaystyle\\lim_{x \\to 0} \\frac{f(x)-f(0)}{x-0}=1$\n\n将 $f(x)$ Taylor 展开，立刻得到\n\n$$\nf(x)=f(0)+f'(0)x+\\frac{f''(\\xi)}{2}x^2=x+\\frac{f''(\\xi)}{2}x^2 \\ge x\n$$\n\n## 积分\n\n### 不定积分\n\n#### 换元积分法\n\n**第一类换元法** 设 $f(u)$ 具有原函数，$u=\\varphi(x)$ 可导，则有换元公式\n\n$$\n\\int f[\\varphi(x)]\\varphi '(x) {\\rm d}x=\\int f(u) {\\rm d}u\n$$\n\n例如，要计算 \n\n$$\n\\int \\frac{ {\\rm d}x}{x(1+2\\ln x)}\n$$\n\n作换元 $u=1+2\\ln x$，则 ${\\rm d}u=\\frac{2{\\rm d}x}{x}$\n\n原式化为\n\n$$\n\\int \\frac{ {\\rm d}u}{2u}=\\frac{\\ln |u|}{2}+C=\\frac{1}{2}\\ln|1+2\\ln x|+C\n$$\n\n**第二类换元法** 设 $x=\\psi(t)$ 是单调的可导函数，并且 $\\psi '(t) \\ne 0$.又设 $f[\\psi(t)]\\psi '(t)$ 具有原函数，则有换元公式\n\n$$\n\\int f(x){\\rm d}x=\\int f[\\psi(t)]\\psi '(t) {\\rm d}t\n$$\n\n例如，在 $a>0$ 时要计算不定积分\n\n$$\n\\int \\sqrt{a^2-x^2} {\\rm d} x\n$$\n\n可以反设 $x=a\\sin t$，其中 $t \\in [-\\frac{\\pi}{2},\\frac{\\pi}{2}]$，于是所求积分化为\n\n$$\n\\int a\\cos t {\\rm d}x\n$$\n\n并且我们有 ${\\rm d}x=a\\cos t {\\rm d}t$，只需积\n\n$$\n\\int a^2\\cos^2 t {\\rm d} t\n$$\n\n这是容易的.\n\n**倒代换**\n\n例如，在 $a \\ne 0$ 时要求 \n\n$$\n\\int \\frac{\\sqrt{a^2-x^2}}{x^4} {\\rm d}x\n$$\n\n作换元 $x=\\frac{1}{t}$，则 ${\\rm d}x=-\\frac{ {\\rm d}t}{t^2}$，于是原积分式化为\n\n$$\n-\\int (a^2t^2-1)^{1/2}|t| {\\rm d}t\n$$\n\n该式又可以化为\n\n$$\n-\\frac{1}{2a^2}\\int (a^2t^2-1)^{1/2} {\\rm d}(a^2t^2-1)=-\\frac{(a^2t^2-1)^{3/2}}{3a^2}+C\n$$\n\n#### 分部积分法\n\n根据 $(uv)'=u'v+uv'$，两侧积分得到\n\n$$\n\\int uv' {\\rm d}x=uv-\\int u'v {\\rm d}x\n$$\n\n也即：\n\n$$\n\\int u {\\rm d}v=uv-\\int v{\\rm d}u\n$$\n\n例如要求 \n\n$$\n\\int x\\cos x {\\rm d}x\n$$\n\n令 $u=x,{\\rm d}v=\\cos x {\\rm d}x$，则 $v=\\sin x$，原积分式就等于\n\n$$\nuv-\\int vdu=x\\sin x-\\int \\sin x{\\rm d}x\n$$\n\n这是容易的.\n\n### 定积分\n\n#### 微积分基本公式\n\n**定积分中值定理** 如果函数 $f(x)$ 在积分区间 $[a,b]$ 上连续，那么在 $(a,b)$ 上至少存在一个点 $\\xi$ 使下式成立：\n\n$$\n\\int_a^b f(x) {\\rm d}x=f(\\xi)(b-a)\n$$\n\n**微积分基本定理** 如果函数 $F(x)$ 是连续函数 $f(x)$ 在区间 $[a,b]$ 上的一个原函数，那么\n\n$$\n\\int_a^b f(x) {\\rm d}x=F(b)-F(a)\n$$\n\n## 微分方程\n\n### 可分离变量的微分方程\n\n解 $\\frac{ {\\rm d}y}{ {\\rm d}x}=2xy^2$\n\n分离变量，化为 $\\frac{ {\\rm d}y}{y^2}=2x {\\rm d}x$，两侧积分得到 $-\\frac{1}{y}=x^2 + C$.\n\n也就是说，我们可以这样解决一部分可以写成 $g(y) {\\rm d}y=f(x) {\\rm d}x$ 的微分方程.\n\n### 齐次方程\n\n如果一阶微分方程可化为 \n\n$$\n\\frac{ {\\rm d}y}{ {\\rm d}x}=\\varphi(\\frac{y}{x})\n$$\n\n那么称它为齐次方程.\n\n此时引入 $u=\\frac{y}{x}$，则 $\\frac{ {\\rm d}y}{ {\\rm d}x}=u+x\\frac{ {\\rm d}u}{ {\\rm d}x}$，回代便得到\n\n$$\nu+x\\frac{ {\\rm d}u}{ {\\rm d}x}=\\varphi(u)\n$$\n\n于是就可以分离变量了.\n\n### 一阶线性微分方程\n\n方程 \n\n$$\n\\frac{ {\\rm d}y}{ {\\rm d}x} + P(x)y=Q(x)\n$$\n\n称作一阶线性微分方程，因为它关于未知函数 $y$ 及其导数是一次方程.当且仅当 $Q(x)=0$ 时称其是齐次的.\n\n为了求出它的解，我们先将 $Q(x)$ 替换为 $0$ 求出其对应的齐次方程的解，它可以分离变量为\n\n$$\n\\frac{ {\\rm d}y}{y}=-P(x) {\\rm d}x\n$$\n\n于是 \n\n$$\n\\ln |y|=-\\int P(x) {\\rm d}x + C_1\n$$\n\n得到\n\n$$\ny=Ce^{-\\int P(x) {\\rm d}x}\n$$\n\n其中 $C=\\pm e^{C_1}$.\n\n现在求原非齐次线性方程的通解.将 $C$ 替换为 $x$ 的未知函数 $u(x)$，则 $y=ue^{-\\int P(x) {\\rm d}x}$.\n\n于是\n\n$$\n\\frac{ {\\rm d}y}{ {\\rm d}x}=u'e^{-\\int P(x) {\\rm d}x}-uP(x)e^{-\\int P(x) {\\rm d}x}\n$$\n\n回代到最初的式子中得到\n\n$$\nu'=Q(x)e^{\\int P(x) {\\rm d}x}\n$$\n\n两侧积分，\n\n$$\nu=\\int Q(x)e^{\\int P(x) {\\rm d}x}+C\n$$\n\n因此\n\n$$\ny=e^{-\\int P(x) {\\rm d}x}\\left( \\int Q(x)e^{\\int P(x) {\\rm d}x}+C \\right)\n$$\n\n上式可改写为\n\n$$\ny=Ce^{-\\int P(x) {\\rm d}x}+e^{-\\int P(x) {\\rm d}x}\\int Q(x)e^{\\int P(x) {\\rm d}x}\n$$\n\n等式右侧第一项是原非齐次线性方程对应的齐次线性方程的通解，第二项是一个特解.\n\n### 伯努利方程\n\n伯努利方程形如\n\n$$\n\\frac{ {\\rm d}y}{ {\\rm d}x}+P(x)y=Q(x)y^n\\quad (n \\ne 0,1)\n$$\n\n只需将其化为线性的.先变形为\n\n$$\ny^{-n}\\frac{ {\\rm d}y}{ {\\rm d}x}+P(x)y^{1-n}=Q(x)\n$$\n\n引入 $z=y^{1-n}$，那么\n\n$$\n\\frac{ {\\rm d}z}{ {\\rm d}x}+(1-n)P(x)z=(1-n)Q(x)\n$$\n\n### 可降阶的高阶微分方程\n\n对于形如 $y^{(n)}=f(x)$ 的求解是容易的，连着积分 $n$ 次即可.\n\n对于形如 $y''=f(x,y')$ 的求解也很简单，设 $y'=p$，求解两个关于 $x,p$ 的一阶微分方程即可.\n\n对于形如 $y''=f(y,y')$ 的微分方程，同样考虑令 $y'=p$，原方程变为 \n\n$$\n\\frac{ {\\rm d}p}{ {\\rm d}x}=f(y,p)\n$$\n\n也即\n\n$$\n\\frac{ {\\rm d}p}{ {\\rm d}y} \\frac{ {\\rm d}y}{ {\\rm d}x}=f(y,p)\n$$\n\n而 $\\frac{ {\\rm d}y}{ {\\rm d}x}$ 就是 $p$，因此只需求解 $p \\frac{ {\\rm d}p}{ {\\rm d}y}=f(y,p)$","tags":["学习笔记","高等数学"],"categories":["数学"]},{"title":"我常常追忆过去","url":"/post/ba11f26f.html","content":"\n我该在哪里停留？我问我自己。\n\n<!--more-->\n\n\n\n{% blockquote 追忆 https://www.luogu.com.cn/problem/P11831 省选联考 2025 %} \n我常常追忆过去。\n\n生命瞬间定格在脑海。我将背后的时间裁剪、折叠、蜷曲，揉捻成天上朵朵白云。\n\n云朵之间亦有分别：积云厚重，而卷云飘渺。生命里震撼的场景掠过我的思绪便一生无法忘怀，而更为普通平常的记忆在时间的冲刷下只留下些许残骸。追忆宛如入梦，太过清楚则无法愉悦自己的幻想，过分模糊却又坠入虚无。只有薄雾间的山水，面纱下的女子，那恰到好处的朦胧，才能满足我对美的苛求。\n\n追忆总在不经意间将我裹进泛黄的纸页里。分别又重聚的朋友，推倒又重建的街道，种种线索协助着我从一个具体的时刻出发沿时间的河逆流而上。曾经的日子无法重来，我只不过是一个过客。但我仍然渴望在每一次追忆之旅中留下闲暇时间，在一个场景前驻足，在岁月的朦胧里瞭望过去的自己，感受尽可能多的甜蜜。美好的时光曾流过我的身体，我便心满意足。\n\n过去已经凝固，我带着回忆向前，只是时常疏于保管，回忆也在改变着各自的形态。这给我的追忆旅程带来些许挑战。\n\n我该在哪里停留？我问我自己。\n{% endblockquote %}\n","tags":["随笔"],"categories":["随笔"]}]