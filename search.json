[{"title":"2025 ICPC Asia EC 网络赛第一场","url":"/post/d45716c2.html","content":"\n\n[比赛链接](https://qoj.ac/contest/2513)\n\n<!--more-->\n\n## A. Who Can Win\n\n模拟题，没啥好说的。\n\n{% fold A. Who Can Win 示例代码 %}\n```cpp A. Who Can Win\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct submit {\n\tstring name; char prob; int tim; string state;\n\tinline void in() {\n\t\tcin >> name >> prob >> tim >> state;\n\t}\n\tbool operator < (const submit &rhs) {\n\t\treturn tim < rhs.tim;\n\t}\n};\nconst int N = 1e5 + 10;\npair<int, int> mx[N], mn[N];\nvector<submit> ar[N];\nstring uid[N];\n\ninline void solve() {\n\tint n; cin >> n;\n\tmap<string, int> id; int cnt = 0;\n\tvector<submit> v(n);\n\tfor(int i = 0; i < n; i ++) {\n\t\tv[i].in();\n\t\tif(!id.count(v[i].name)) {\n\t\t\tid[v[i].name] = ++cnt; \n\t\t\tuid[cnt] = v[i].name;\n\t\t}\n\t}\n\tfor(int i = 1; i <= cnt; i ++)\n\t\tmx[i] = {0, 0}, mn[i] = {0, 0};\n\tfor(int i = 1; i <= cnt; i ++) ar[i].clear();\n\tfor(int i = 0; i < n; i ++)\n\t\tar[id[v[i].name]].push_back(v[i]);\n\tfor(int i = 1; i <= cnt; i ++) {\n\t\tsort(ar[i].begin(), ar[i].end());\n\t\tbool ok[26];\n\t\tint siz[26];\n\t\tfor(int j = 0; j < 26; j ++) \n\t\t\tok[j] = false, siz[j] = 0;\n\t\tfor(auto x : ar[i]) {\n\t\t\tif(ok[x.prob - 'A']) continue;\n\t\t\tif(x.state == \"Accepted\") {\n\t\t\t\tok[x.prob - 'A'] = true;\n\t\t\t\tmx[i].first ++, mn[i].first ++;\n\t\t\t\tmx[i].second += x.tim, mn[i].second += x.tim;\n\t\t\t\tmx[i].second += siz[x.prob - 'A'] * 20;\n\t\t\t\tmn[i].second += siz[x.prob - 'A'] * 20;\n\t\t\t} else if(x.state == \"Rejected\") {\n\t\t\t\tsiz[x.prob - 'A'] ++;\n\t\t\t} else {\n\t\t\t\tint y = x.prob - 'A';\n\t\t\t\tmx[i].first ++, mx[i].second += x.tim;\n\t\t\t\tmx[i].second += siz[x.prob - 'A'] * 20;\n\t\t\t\tok[y] = true;\n\t\t\t}\n\t\t}\n\t}\n\tsort(mn + 1, mn + cnt + 1, [&](pair<int, int> a, pair<int, int> b) {\n\t\tif(a.first != b.first) return a.first > b.first;\n\t\treturn a.second < b.second;\n\t});\n\tvector<string> ans;\n\tfor(int i = 1; i <= cnt; i ++) {\n\t\tif((mx[i].first > mn[1].first) || (mx[i].first == mn[1].first && mx[i].second <= mn[1].second)) {\n\t\t\tans.push_back(uid[i]);\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\tfor(auto s : ans)\n\t\tcout << s << ' ';\n\tcout << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tint T; cin >> T;\n\twhile(T --) solve();\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## B. Creating Chaos\n\n结论：最终剩下连续的 $n-k$ 个数最优。\n\n证明考虑原式等于\n\n$$\n\\sum_{d | n} \\varphi(d) \\sum_{i < j} [|a_i-a_j| \\bmod d = 0]\n$$\n\n这是因为 $n=\\sum_{d | n} \\varphi(d)$。\n\n对于 $\\sum_{i<j} [|a_i-a_j| \\bmod d = 0]$，我们可以以 $0$ 的代价先取遍 $0$ 到 $d-1$，之后，尽量选模 $d$ 意义下不同的数会优于选相同的数，因此直接选择留下 $1,2,3,\\cdots ,n-k$ 是最优的（或者选其它长度为 $n-k$ 的连续段）。\n\n{% fold B. Creating Chaos 示例代码 %}\n```cpp B. Creating Chaos\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tint n, k; cin >> n >> k;\n\tfor(int i = 1; i <= k; i ++)\n\t\tcout << i << ' ';\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## C. Canvas Painting\n\n贪心，从小到大依次考虑每个数是否可以变为前面的数使得最终答案减一。\n\n为此，我们用一个小根堆维护可以覆盖当前考虑到的位置的区间的右端点，每次选择右端点最小的那个区间，用这个区间的操作改变当前位置即可，时间复杂度 $\\mathcal{O}(m \\log m)$\n\n{% fold C. Canvas Painting\n 示例代码 %}\n```cpp C. Canvas Painting\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void solve() {\n\tint m, n; cin >> m >> n;\n\tmap<int, vector<int>> Map;\n\tfor(int i = 0; i < m; i ++) {\n\t\tint l, r; cin >> l >> r;\n\t\tif(l < r) Map[l].push_back(r);\n\t}\n\tauto it = Map.begin(); int pos = 1, ans = n;\n\tpriority_queue<int, vector<int>, greater<int>> Q;\n\twhile(pos < n) {\n\t\tif(Map.count(pos)) {for(int r : Map[pos]) Q.push(r); }\n\t\twhile(!Q.empty() && Q.top() <= pos) Q.pop();\n\t\tif(Q.empty()) {\n\t\t\twhile(it != Map.end() && it->first <= pos) ++it;\n\t\t\tif(it == Map.end()) break;\n\t\t\telse pos = it->first;\n\t\t} else Q.pop(), pos ++, ans --;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tint T; cin >> T;\n\twhile(T --) solve();\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## D. Min-Max Tree\n\n引理1：存在一种最优的切分方式使得最终的每个连通块中，值最小、最大的点均是叶子。\n\n这是因为如果不是叶子，将多余的部分分为另一个连通块一定不会更劣。\n\n引理2：存在一种最优的切法使得最终每个连通块都是链。\n\n和引理 1 类似，拎出最大、最小结点构成的那条链，剩下的部分可以切出去，白赚了一些连通块，不会更劣。\n\n因此，我们可以直接钦定最终切出了一堆链，并且链的两端分别是最大、最小值。\n\n根据这个树形dp，设 $f_u$ 表示 $u$ 子树的答案， $g_u$ 表示 $u$ 子树内有一条伸出子树的链，链的最大值已经算进贡献的答案，$h_u$ 表示 $u$ 子树内有一条伸出子树的链，链的最小值已经算进贡献的答案，时间复杂度 $\\mathcal{O}(n)$\n\n{% fold D. Min-Max Tree 示例代码 %}\n```cpp D. Min-Max Tree\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\nint n, A[N];\nvector<int> G[N];\n\nlong long f[N], g[N], h[N];\n// f: 闭合\n// g: 作为左端点\n// h: 作为右端点\nvoid dfs(int u, int fa) {\n\tlong long sum = 0;\n\tfor(int v : G[u]) {\n\t\tif(v == fa) continue;\n\t\tdfs(v, u);\n\t\tsum += f[v];\n\t}\n\tf[u] = sum, g[u] = A[u] + sum, h[u] = -A[u] + sum;\n\tvector<long long> v_h, v_g;\n\tfor(int v : G[u]) {\n\t\tif(v == fa) continue;\n\t\tif(A[u] > A[v]) {\n\t\t\tf[u] = max(f[u], sum - f[v] + A[u] + h[v]);\n\t\t\tv_h.push_back(-f[v] + h[v]);\n\t\t\th[u] = max(h[u], sum - f[v] + h[v]);\n\t\t}\n\t\tif(A[u] < A[v]) {\n\t\t\tf[u] = max(f[u], sum - f[v] - A[u] + g[v]);\n\t\t\tg[u] = max(g[u], sum - f[v] + g[v]);\n\t\t\tv_g.push_back(-f[v] + g[v]);\n\t\t}\n\t}\n\tif(!v_h.empty() && !v_g.empty()) {\n\t\tsort(v_h.begin(), v_h.end(), greater<long long>());\n\t\tsort(v_g.begin(), v_g.end(), greater<long long>());\n\t\tf[u] = max(f[u], sum + v_h[0] + v_g[0]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> A[i];\n\tfor(int i = 1; i < n; i ++) {\n\t\tint a, b; cin >> a >> b;\n\t\tG[a].push_back(b), G[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tcout << f[1] << '\\n';\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## F. Robot\n\n策略：先堵上一个角 $(28,28)$，$(27,28)$，$(28,27)$，然后尽量隔 $1$ 填 $2$，即尽可能如图所示地堵：\n\n![](/images/d45716c2.png)\n\n将机器人困在这个矩形内后，不断堵它脚下即可。\n\n优先级为：\n\n- 优先堵边界\n\n- 边界上，优先堵图中所示的`X`和机器人一步可以走到的位置（否则机器人就跑出去了）\n\n- 边界上优先级的第二个关键字为它到机器人的曼哈顿距离\n\n这样，机器人无论如何也走不出这个矩形。\n\n{% fold F. Robot 示例代码 %}\n```cpp F. Robot\n#include <bits/stdc++.h>\n\nusing namespace std;\nint x, y;\nbool vis[50][50];\ninline void mark(int a, int b) {\n\tvis[a][b] = true;\n\tcout << a << ' ' << b << endl;\n\tcin >> x >> y;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tint B = 28;\n\tcin >> x >> y;\n\tmark(B, B), mark(B - 1, B), mark(B, B - 1);\n\twhile(x || y) {\n\t\tarray<int, 3> A = {1000, x, y};\n\t\tfor(int i = 1; i <= B; i ++) {\n\t\t\tif(!vis[B][i]) {\n\t\t\t\tarray<int, 3> T = {((abs(B - x) > 1 || abs(i - y) > 1) && (i % 3 == 2)) * 500 + abs(B - x) + abs(i - y),\n\t\t\t\t\t\t\t\t\tB, i};\n\t\t\t\tA = min(A, T);\n\t\t\t}\n\t\t\tif(!vis[i][B]) {\n\t\t\t\tarray<int, 3> T = {((abs(i - x) > 1 || abs(B - y) > 1) && (i % 3 == 2)) * 500 + abs(i - x) + abs(B - y),\n\t\t\t\t\t\t\t\t\ti, B};\n\t\t\t\tA = min(A, T);\n\t\t\t}\n\t\t}\n\t\tmark(A[1], A[2]);\n\t}\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## G. Sorting\n\n答案为`Yes`当且仅当存在`1 2`，`2 3`,......，`n-1 n`。\n\n首先，如果这些都存在的话，答案一定为`Yes`，否则，如果不存在`i i+1`，构造序列`1 2 3 ... i-1 i+1 i i+2 ... n`，它无法被正确排序。\n\n{% fold G. Sorting 示例代码 %}\n```cpp G. Sorting\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tint n, m; cin >> n >> m;\n\tvector<int> ok(n + 1, 0);\n\tfor(int i = 0; i < m; i ++) {\n\t\tint a, b; cin >> a >> b;\n\t\tif(b == a + 1) ok[a] = 1;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i < n; i ++) ans += ok[i];\n\tcout << (ans == n - 1 ? \"Yes\" : \"No\") << '\\n';\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## I. Knapsack Problem\n\n把边反向，以 $T$ 为起点跑Dijkstra即可，距离为一个二元组，包含已用的背包数和当前背包所用的容量。\n\n{% fold I. Knapsack Problem 示例代码 %}\n```cpp I. Knapsack Problem\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint n, m, V, S;\nvector<pair<int, int>> G[N];\n\npair<int, int> dist[N];\nbool vis[N];\ninline void Dijkstra() {\n\tfor(int i = 1; i <= n; i ++)\n\t\tdist[i] = {INF, 0};\n\tdist[S] = {1, 0};\n\tpriority_queue<pair<pii, int>, vector<pair<pii, int>>, greater<pair<pii, int>>> Q;\n\tQ.push({dist[S], S});\n\twhile(!Q.empty()) {\n\t\tint u = Q.top().second; Q.pop();\n\t\tif(vis[u]) continue; vis[u] = true;\n\t\tfor(auto [v, w] : G[u]) {\n\t\t\tpii x = dist[u];\n\t\t\tif(x.second + w <= V) x.second += w;\n\t\t\telse x.first ++, x.second = w;\n\t\t\tif(x < dist[v]) {\n\t\t\t\tdist[v] = x, Q.push({dist[v], v});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tcin >> n >> m >> V >> S;\n\tfor(int i = 0; i < m; i ++) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tif(c > V) continue;\n\t\tG[b].push_back({a, c});\n\t\tG[a].push_back({b, c});\n\t}\n\tDijkstra();\n\tfor(int i = 1; i <= n; i ++) \n\t\tcout << (dist[i].first == INF ? -1 : dist[i].first) << \" \\n\"[i == n];\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## J. Moving on the Plane\n\n曼哈顿转切比雪夫，即将坐标 $(x,y)$ 变为 $(x+y,x-y)$，每次移动会变为 $(x\\pm 1,y\\pm 1)$，两维独立。\n\n原作标下的曼哈顿距离等于新坐标下的切比雪夫距离，因此现在要求对于任意两点 $(x_1,y_1)$ 和 $(x_2,y_2)$，满足\n\n$$\n\\max(|x_1-x_2|,|y_1-y_2|) \\le K\n$$\n\n也就是 $|x_1-x_2| \\le K$ 并且 $|y_1-y_2| \\le K$，两维独立，分别做后乘法原理即可。\n\n现在的问题转化为，数轴上给定初始的 $n$ 个点，每个点可以走 $m$ 步，每步 $\\pm 1$，要数最终这些点处于一个长度不超过 $K$ 的区间内的方案数。\n\n枚举长度为 $K$ 的区间的起点并钦定左端点至少存在一个点，再算出每个点最终落在这个区间的方案数即可，总时间复杂度 $\\mathcal{O}(nmk)$，其中 $m$ 是值域。\n\n{% fold J. Moving on the Plane 示例代码 %}\n``` J. Moving on the Plane\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 55, M = 1e5 + 10, K = 15;\nconst int P = 998244353;\ninline int Plus(int a, int b) {return a + b >= P ? a + b - P : a + b; }\ninline int Minus(int a, int b) {return a - b < 0 ? a - b + P : a - b; }\ninline int ksm(long long a, int b) {\n\tlong long r = 1;\n\tfor(; b; b >>= 1, a = a * a % P)\n\t\tif(b & 1) r = r * a % P;\n\treturn r;\n}\nint fac[M], ifac[M];\ninline int binom(int a, int b) {\n\tif(a >= b) return 1ll * fac[a] * ifac[b] % P * ifac[a - b] % P;\n\telse return 0;\n}\nint n, m, k, x[N], y[N];\n\ninline int calc(vector<int> v) {\n\tint ans = 0;\n\tfor(int l = -100000 - m; l <= 100000 + m; l ++) {\n\t\tint r = l + k;\n\t\tlong long add = 1, sub = 1;\n\t\tfor(int x : v) {\n\t\t\tint A = 0, B = 0;\n\t\t\tfor(int p = l; p <= r; p ++) {\n\t\t\t\tint d = p - x;\n\t\t\t\tif(abs(d) > m || (m + d) % 2) continue;\n\t\t\t\tint y = binom(m, (m + d) / 2);\n\t\t\t\tA = Plus(A, y); if(p > l) B = Plus(B, y);\n\t\t\t}\n\t\t\tadd = add * A % P, sub = sub * B % P;\n\t\t}\n\t\tans = Plus(ans, add), ans = Minus(ans, sub);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tcin >> n >> m >> k;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= m; i ++) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[m] = ksm(fac[m], P - 2);\n\tfor(int i = m; i >= 1; i --) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tint a, b; cin >> a >> b;\n\t\tx[i] = a + b, y[i] = a - b;\n\t}\n\tvector<int> a(x + 1, x + n + 1), b(y + 1, y + n + 1);\n\tcout << 1ll * calc(a) * calc(b) % P << '\\n';\n\n\treturn 0;\n}\n```\n{% endfold %}\n\n## K. Counting\n\n设 $[x^ny^m]$ 表示 $n$ 个点的无标号有根树中，恰有 $m$ 个点有恰 $k$ 个儿子的方案数，那么\n\n$$\nF=x\\left(\\frac{1}{1-F}-F^k+yF^k\\right)\n$$\n\n拉反，由于 $x=\\dfrac{F}{\\frac{1}{1-F}+(y-1)F^k}$，于是 $F$ 的复合逆为 $G=\\dfrac{x}{\\frac{1}{1-x}+(y-1)x^k}$，拉反得到\n\n$$\n[x^n]F=\\frac{1}{n}[x^{n-1}]\\left(\\frac{1}{1-x}+(y-1)x^k\\right)^n\n$$\n\n推推式子，有\n\n$$\n[x^n]F=\\frac{1}{n}[x^{n-1}]\\sum_{i\\ge 0}\\sum_{j \\ge 0}\\binom{n}{i}\\binom{i}{j}y^j(-1)^{i-j}x^{ki}\\left(\\frac{1}{1-x}\\right)^{n-i}\n$$\n\n于是\n\n$$\n\\begin{aligned}\n.[x^ny^m]F&=\\frac{1}{n}[x^{n-1}]\\sum_{i \\ge m}\\binom{n}{m}\\binom{n-m}{i-m}(-1)^{i-m}x^{ki}\\left(\\frac{1}{1-x}\\right)^{n-i}\\\\\n&=\\frac{1}{n}\\binom{n}{m}[x^{n-1}]x^{km}\\sum_{i \\ge 0}\\binom{n-m}{i}(-x^k)^i\\left(\\frac{1}{1-x}\\right)^{n-m-i}\\\\\n&=\\frac{1}{n}\\binom{n}{m}[x^{n-1}]x^{km}\\left( \\frac{1}{1-x}-x^k \\right)^{n-m}\n\\end{aligned}\n$$\n\n## M. Teleporter\n\n首先最终的路径一定是：走树边、传送、走树边、传送交替进行。\n\n考虑按 $k$ 升序求出每个答案，设 $dp_u$ 表示此时到 $u$ 的最短距离，每次处理出之后只需要遍历每个传送边 $(u,v)$ 并更新 $dp'_u=\\min(dp'_u,dp_v)$ 即可多走一个传送边，这部分的复杂度是 $\\mathcal{O}(mk)$。考虑用树边更新最短路的方式，一定是先向上走若干步，再向下走到某个结点，更新最短路，因此可以分两步进行，这部分的时间复杂度为 $\\mathcal{O}(nk)$。\n\n两部分合起来即可，总时间复杂度 $\\mathcal{O}(nk+mk)$。\n\n{% fold M. Teleporter 示例代码 %}\n```cpp M. Teleporter\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\nint n, m; vector<pair<int, int>> G[N];\n\nvector<array<int, 3>> up, down;\nvoid dfs(int u, int fa) {\n\tfor(auto [v, w] : G[u]) {\n\t\tif(v == fa) continue;\n\t\tdown.push_back({u, v, w});\n\t\tdfs(v, u);\n\t\tup.push_back({v, u, w});\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tcin >> n >> m;\n\tfor(int i = 1; i < n; i ++) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tG[a].push_back({b, c}), G[b].push_back({a, c});\n\t}\n\tvector<pair<int, int>> tel(m);\n\tfor(int i = 0; i < m; i ++) cin >> tel[i].first >> tel[i].second;\n\tdfs(1, 0);\n\n\tvector<long long> dp(n + 1, INF);\n\tdp[1] = 0;\n\tfor(int k = 0; k <= n; k ++) {\n\t\tfor(auto [u, v, w] : up)\n\t\t\tdp[v] = min(dp[v], dp[u] + w);\n\t\tfor(auto [u, v, w] : down)\n\t\t\tdp[v] = min(dp[v], dp[u] + w);\n\t\tlong long ans = 0;\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tans += dp[i];\n\t\tcout << ans << '\\n';\n\t\tvector<long long> new_dp = dp;\n\t\tfor(auto [u, v] : tel) {\n\t\t\tnew_dp[u] = min(new_dp[u], dp[v]);\n\t\t\tnew_dp[v] = min(new_dp[v], dp[u]);\n\t\t}\n\t\tdp = new_dp;\n\t}\n\n\treturn 0;\n}\n```\n{% endfold %}","tags":["ICPC","题解"],"categories":["OI"]},{"title":"写给学弟们","url":"/post/18083b71.html","content":"\n写给还在一中的，所有的OIer.\n\n<!--more-->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=2619647261&auto=0&height=66\"></iframe>\n\n前几天刚刚要开学的时候，闫墨发来了一个消息，要写一篇“致高三学弟学妹的一封信（100字左右），分享学习经验和心得”，我拖到现在，随便水了几条就180字了，想说的很多话不想放到那里，似乎也不能放到那里，正好现在闲了一会，就来写写吧。\n\n高一的时候，我记得很清楚，刚开学我就开始选择翘一些课去搞OI或者去摸鱼，此时翘的是政治历史地理这样的学考课，事实证明翘掉这些课也没有任何影响：我在几乎没有上过课的基础上，在考前大约5天看了课本并且每科写了一些卷子之后，我就做到了政治历史A，地理B。B也无所谓，我也就懒得再考了。大约一两个月之后？我就开始翘一些主课，事实证明翘课是会上瘾的，整个高一高二，我上课的时间加起来应该不会超过一学期。这是前提。\n\n到了高三，第一次考试赋完分之后我考了390，排名没看，至今我也不知道为啥当时只有390，分数分布可能是100+100+110+20+30+30之类的神秘东西。我记得当时数学的T19是组合新定义，我丢掉了前面那些圆锥曲线立体几何啥的东西去做，最后好像也没拿到几分，但我自认为我是写出来了的，可能是记号问题吧。\n\n后面一段时间，我的分数从390涨到500，再到550，再到大约580，590，600这个区间后就几乎不变直到高考了，期间考过最高的一次是619，然而我的高考分数是673。说来好笑，我物化生三科的历史最高分竟然都落在了高考。\n\n说了这么多，我想说的唯一一点就是，相信自己，放平心态，让自己开心一点，洒脱一点。\n\n我高中读课外书都是在高考前一段时间，晚自习的时候出去看花也只有高考前一段时间，真正融入班级也只有高三这一年。高三其实还挺好玩的。恋爱就算了吧，早干啥去了。\n\n高考结束后，我信誓旦旦要去写一篇回忆录，但事实是写了一些后就被我隐藏了，原因是在我尝试写一些真心话时，我才发现这是我想写给自己听的东西，我打下的文字也还不足以呈现出我想要说出口的内容，这是不是也叫欲说还休？\n\n趁着高三把自己还没来得及做的事都做了吧。考完生物的那个下午，我踩着小雨走进了超越楼，坐上电梯去到了图书角。图书角里有很多书，本来在那里的，毕业的同学塞到那里的，填满了所有位置。我一本一本地看过去，取走了我想要的那一本，然后离开了这里。本来想要再拍一下小学部里的秋千，但最后还是匆忙离开了。\n\n再回到学校拿毕业证，书架上的书已经被清空了。\n\n高三很累，可能也会很苦，但我也希望你们能学会苦中作乐，跟在机房里学OI一样。\n\n说到底，这不是一篇成功学指南，而是我站在终点回望时，想对还在路上的你们说：别怕迷茫，相信自己，认真生活。\n\n写给即将高考的所有HYOIer，也写给所有看到这篇文章的，还在一中里迷茫的同学。","tags":["随笔"],"categories":["随笔"]},{"title":"支配树","url":"/post/66125d24.html","content":"\n支配树学习笔记\n\n<!--more-->\n\n定义：\n\n- $\\operatorname{dfn}(u)$ 表示 $u$ 的DFS序。\n- 对于DFS树上的两个点 $u,v$，定义 $u<v$ 当且仅当 $u$ 的DFS序比 $v$ 的DFS序小\n\n## 问题\n\n给定一张有向图 $G$ 和源点 $S$，并且 $S$ 可达所有点。称点 $u$ 支配点 $v$ 当且仅当所有从 $S$ 到 $v$ 的路径必定经过点 $u$（特别地，一个点不支配它自身），支配树就是用来刻画这样的支配关系的结构。\n\n## 支配关系的性质\n\n若 $u$ 支配点 $v$，则称 $u$ 是 $v$ 的支配点，记作 $u \\operatorname{dom} v$。一个关键性质是：支配关系构成偏序。\n\n易证如下性质：\n\n- 若 $u \\operatorname{dom} v$ 且 $v \\operatorname{dom} w$，则 $u \\operatorname{dom} w$\n- $u$ 不支配它自身（特别定义）\n- 若 $u \\operatorname{dom} w$ 并且 $v \\operatorname{dom} w$，那么必然有 $u \\operatorname{dom} v$ 或 $v \\operatorname{dom} u$\n\n依据如上三条性质，定义 $u$ 的最近支配点为离它最近的支配点，它被 $u$ 的其它所有支配点支配，记作 $\\operatorname{idom}(u)$。\n\n换句话说，存在一个根为 $S$ 的树形结构，点 $u$ 的所有祖先即为 $u$ 的支配点，$u$ 的父亲为 $u$ 的最近支配点，称该结构为**支配树**，下面我们考虑如何得到该结构。\n\n## 支配树的求解\n\n下面，我们首先探讨 $G$ 为DAG时如何求出其支配树，然后再考虑如何将一般图的支配树等价到一个DAG上的支配树，套用求DAG支配树的解法即可。\n\n### DAG的支配树\n\n当 $G$ 为一个DAG时，点 $u$ 的最近支配点就是它的所有前驱在支配树上的LCA，于是我们只需要按照拓扑序，实现动态加叶子以及快速求LCA即可，这可以用倍增LCA解决，总时间复杂度为 $\\mathcal{O}(m \\log m)$。\n\n### 一般图的支配树\n\n我们分两步解决这个问题，第一步是将其规约到DAG的支配树，第二步是快速求出归约到的那个DAG。\n\n#### 将一般图的支配树转化为DAG的支配树\n\n首先以 $S$ 为根构建出任意一棵DFS树，称为树 $T$，显然，$u$ 的支配点在DFS树上必然是 $u$ 的祖先（反过来则不一定成立）。\n\n如果 $u$ 不支配 $v$（其中 $u$ 是 $v$ 在树 $T$ 上的祖先），那么必然存在一个子树 $u$ 之外的结点 $t$，它能不经过点 $u$ 到达点 $v$（从 $S$ 到达 $t$ 是不会经过点 $u$ 的，因为它不在 $u$ 的子树内）。\n\n$t$ 如何不经过 $u$ 到达 $v$？必然是先到达了树 $T$ 上 $u \\rightsquigarrow v$ 路径上的某一点 $r$（$r \\ne u$），然后通过树边向下到达 $v$。记DFS树上 $t$ 与 $r$ 的LCA为 $w$，则树上路径 $w \\rightsquigarrow r$（不含端点）中的所有点均不再支配 $r$ 的子树，显然，对于某一个固定的 $r$，只有最远的 $w$ 是有用的，称该点为 $r$ 的**半支配点**，记作 $\\operatorname{sdom}(u)$。\n\n换句话说，$w$ 是 $r$ 的半支配点，当且仅当：\n\n- $w$ 是 $r$ 在DFS树上的祖先\n- 可以从 $w$ 出发，不经过树上路径 $w \\rightsquigarrow r$（不含端点）外的其它点到达 $r$\n- $w$ 是满足上述条件且深度最浅的那个点\n\n我们在DFS树中加入边 $w \\to r$，相当于消除了 $w \\rightsquigarrow r$（不含端点）上的点对 $r$ 子树的支配，如果在DFS树中对所有的 $u$ 都加入边 $v \\to u$（其中 $v$ 是 $u$ 的半支配点），那么该图的支配关系与原图完全相同！\n\n于是我们得到了最为关键的一条引理，叙述如下。\n\n**引理：** 原图 $G$ 的支配树等价于仅考虑如下边的图的支配树\n\n- DFS树上的树边\n- 每个点 $u$ 的半支配点到 $u$ 的连边，即对于每个点 $u$，加入一条边 $\\operatorname{sdom}(u) \\to u$\n\n原因在于图 $G$ 的每对不支配关系都被第二类边表达了。\n\n注意到我们构造出的新图是一个DAG（$\\operatorname{sdom}(u)$ 是 $u$ 的祖先），而求解DAG的支配树是我们最开始就解决了的问题，所以我们的任务仅有：如何对每个点 $u$ 求出其半支配点.\n\n#### 半支配点的求解\n\n首先，我们给出一个性质：路径 $\\operatorname{sdom}(u) \\rightsquigarrow u$ 上，除端点以外的点的DFS序均大于 $\\operatorname{dfn}(u)$，证明如下：\n\n首先，路径中到达的深度最小的结点即为 $\\operatorname{sdom}(u)$，否则设深度最小的结点为 $p$，那么 $p$ 满足半支配点的前两个条件且深度更小，那么 $p$ 才应该是 $u$ 的半支配点。\n\n将从 $\\operatorname{sdom}(u)$ 到达 $u$ 的路径分为两部分，\n\n1. 从 $\\operatorname{sdom}(u)$ 到达 $u$ 的子树\n2. 从 $u$ 的子树到达 $u$\n\n对于第一部分，必然是先走到一个异于 $u$ 所在子树的子树，再通过横叉边到达 $u$ 的子树，而走横叉边会使DFS序减小，并且原先子树中每个点的DFS序都要大于终点的DFS序，所以第一部分中的点满足条件。\n\n对于第二部分， $u$ 子树中的点的DFS序显然都大于 $u$ 的DFS序，结论自然成立。\n\n因此，$\\operatorname{sdom}(u)$ 即为，除端点外只经过DFS序大于 $\\operatorname{dfn}(u)$ 的点可以到达 $u$ 的点中DFS序最小的那一个。\n\n**补充** 先前只证明了充分性，但必要性是显然的，即「若一个点 $v$ 可以只经过DFS序大于 $\\operatorname{dfn}(u)$ 的点到达 $u$，那么 $v$ 半支配 $u$」，其中 $v$ 是 $u$ 的祖先。\n\n**引理：** $\\operatorname{sdom} u=\\min \\left( \\{v | v\\to u,v<u\\}, \\{\\operatorname{sdom} w| w>u,w\\text{是}u\\text{某个大于}u \\text{的前驱的祖先} \\} \\right)$\n\n按照DFS序的逆序，用并查集维护DFS树上当前的连通块即可求出每个点的半支配点。\n\n于是我们就成功在 $\\mathcal{O}(n \\alpha(n,m))$ 的时间复杂度内构造出了这个DAG，套用DAG上做法即可。\n\n{% fold 转DAG后在DAG上求解支配树 %}\n```cpp\n// 洛谷 P5180\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5e5 + 10, M = 1e6 + 10;\nint n, m, h[N], e[M], ne[M], idx;\nvector<int> pre[N], son[N]; int fa[N];\ninline void add(int a, int b) {\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\n\nint dfn[N], A[N], dfs_clock;\nint sdom[N];\nvoid dfs(int u) {\n    dfn[u] = ++dfs_clock, A[dfs_clock] = u;\n    for(int i = h[u]; i != -1; i = ne[i]) {\n        int v = e[i];\n        if(!dfn[v]) son[u].emplace_back(v), fa[v] = u, dfs(v);\n    }\n}\nint p[N], ans[N];\nint find(int x) {\n    if(x == p[x]) return x;\n    find(p[x]);\n    if(dfn[ans[p[x]]] < dfn[ans[x]]) ans[x] = ans[p[x]];\n    p[x] = p[p[x]]; return p[x];\n}\n\nint anc[20][N], dep[N];\ninline int lca(int u, int v) {\n    if(dep[u] < dep[v]) swap(u, v);\n    for(int i = 19; i >= 0; i --)\n        if(dep[anc[i][u]] >= dep[v]) \n            u = anc[i][u];\n    if(u == v) return u;\n    for(int i = 19; i >= 0; i --)\n        if(anc[i][u] != anc[i][v])\n            u = anc[i][u], v = anc[i][v];\n    return anc[0][u];\n}\n\nint siz[N]; vector<int> DT_son[N];\nvoid dfs_DT(int u) {\n    siz[u] = 1;\n    for(int v : DT_son[u])\n        dfs_DT(v), siz[u] += siz[v];\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    memset(h, -1, sizeof h);\n\n    cin >> n >> m;\n    for(int i = 0; i < m; i ++) {\n        int a, b; cin >> a >> b;\n        add(a, b); pre[b].emplace_back(a);\n    }\n    dfs(1); assert(dfs_clock == n);\n    for(int i = 1; i <= n; i ++)\n        p[i] = i;\n    for(int i = n; i >= 2; i --) {\n        int u = A[i]; sdom[u] = u;\n        for(int v : pre[u]) {\n            if(dfn[v] >= dfn[u]) {\n                find(v);\n                if(dfn[ans[v]] < dfn[sdom[u]])\n                    sdom[u] = ans[v];\n            } else if(dfn[v] < dfn[sdom[u]]) sdom[u] = v; \n        }\n        ans[u] = sdom[u];\n        for(int v : son[u]) p[v] = u;\n    }\n    sdom[1] = 1, dep[1] = 1;\n    for(int i = 2; i <= n; i ++) {\n        int u = A[i];\n        anc[0][u] = lca(fa[u], sdom[u]); dep[u] = dep[anc[0][u]] + 1;\n        DT_son[anc[0][u]].emplace_back(u);\n        for(int j = 1; anc[j - 1][u] && (1 << j) <= n; j ++)\n            anc[j][u] = anc[j - 1][anc[j - 1][u]];\n    }\n    dfs_DT(1);\n    for(int i = 1; i <= n; i ++)\n        cout << siz[i] << \" \\n\"[i == n];\n\n    return 0;\n}\n```\n{% endfold %}\n\n#### 通过半支配点直接求出支配点\n\n上面的方法需要建出很多图，是否可以利用半支配点直接求出支配点呢？\n\n**引理** 记 $v$ 是在DFS树中 $\\operatorname{sdom} u \\rightsquigarrow u$ 链上半支配点的DFS序最小的点，那么\n\n$$\n\\operatorname{idom}u=\\begin{cases}\n\\operatorname{sdom} u &\\operatorname{sdom}u=\\operatorname{sdom} v\\\\\n\\operatorname{idom} v& \\operatorname{sdom}u>\\operatorname{sdom}v\n\\end{cases}\n$$","tags":["学习笔记"],"categories":["数据结构"]},{"title":"2024ICPC昆明","url":"/post/ae0074f0.html","content":"\n[比赛链接](https://codeforces.com/gym/105588)\n\n<!--more-->\n\n## B. Brackets\n\n首先，选出的两段要么均为空，要么一个为一堆左括号，另一个为一堆右括号且它们互补。\n\n考虑给定的每一段区间，若它消除后剩下的是一堆左括号，则将剩下的那些左括号的哈希值塞进一个`std::map`中，然后将所有括号取反并翻转序列，重新做如上操作并将哈希值塞进另一个`std::map`中，这样就分别求得了“留下来的是左括号的序列的哈希值”和“留下来的是右括号的序列所能匹配的左括号序列的哈希值”，将它们贪心地匹配即可。\n\n问题在于如何求得这些区间消除后的哈希值：从左往右依次考虑每个括号并维护一个栈，如果遇到一个左括号则将它入栈，否则如果它与栈顶匹配，则消除，否则清空栈。\n\n当考虑完第 $r$ 个括号时，处理右端点为 $l$ 的询问，设其左端点为 $l$：\n- 如果左端点在某对匹配的括号内部，则该区间消除后的前缀一定是一个右括号（这对匹配的括号中的右括号无法消除），无需处理。\n- 否则栈中所有位于该左端点右侧的左括号即为消除完后剩下的左括号序列，计算它的哈希值即可。\n\n总时间复杂度为 $\\mathcal{O}(n + m \\log m)$，若用`std::unordered_map`可以做到线性。\n\n{% fold B. Brackets 示例代码 %}\n```cpp B. Brackets\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull BASE = 131;\nmap<char, int> Map;\n\nconst int N = 5e5 + 10;\nint n, m, A[N];\null Base[N];\nvector<int> L[N];\nint ans;\n\nmap<ull, int> calc() {\n    map<ull, int> f;\n    static int stk[N], sz[N], tp[N];\n    static ull hash_val[N];\n    int lim = 0, top = 0;\n    for(int i = 1; i <= n; i ++) {\n        if(A[i] & 1) {\n            if((A[stk[top]] ^ A[i]) != 1) \n                top = 0, lim = i;\n            else \n                top --;\n        } else {\n            stk[++top] = i;\n            hash_val[top] = hash_val[top - 1] * BASE + A[i];\n        }\n        sz[i] = top, tp[i] = stk[top];\n        for(int j : L[i]) if(j >= lim) {\n            if(sz[i] < sz[j] || tp[j] != stk[sz[j]]) \n                continue;\n            if(sz[i] > sz[j]) {\n                ull hash = hash_val[top] - hash_val[sz[j]] * Base[sz[i] - sz[j]];\n                f[hash] ++;\n            } else ans ++;\n        }\n    }\n    return f;\n}\n\ninline void solve() {\n    cin >> n >> m;\n    string S; cin >> S;\n    vector<pair<int, int>> in(m);\n    for(int i = 0; i < m; i ++)\n        cin >> in[i].first >> in[i].second;\n    for(int i = 0; i < n; i ++)\n        A[i + 1] = Map[S[i]];\n    for(auto [l, r] : in) L[r].emplace_back(l - 1);\n    ans = 0;\n    auto f = calc();\n    for(int i = 1; i <= n; i ++)\n        A[i] ^= 1, L[i].clear();\n    reverse(A + 1, A + n + 1);\n    for(int i = 0; i < m; i ++) {\n        in[i].first = n - in[i].first + 1;\n        in[i].second = n - in[i].second + 1;\n        swap(in[i].first, in[i].second);\n        L[in[i].second].emplace_back(in[i].first - 1);\n    }\n    auto g = calc();\n    for(int i = 1; i <= n; i ++)\n        L[i].clear();\n    ans /= 4;\n    for(auto [x, y] : f) ans += min(y, g[x]);\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    Base[0] = 1;\n    for(int i = 1; i < N; i ++)\n        Base[i] = Base[i - 1] * BASE;\n    Map['('] = 2, Map[')'] = 3, Map['['] = 4, Map[']'] = 5;\n    Map['{'] = 6, Map['}'] = 7, Map['<'] = 8, Map['>'] = 9;\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## C. Coin\n\n考虑从最后倒推回去，这需要两部分的计算：\n\n- 操作需要几轮才会结束\n- 操作后的第 $p$ 个位置在操作前的位置\n\n先考虑第一部分，一次操作会使元素数量减少 $\\lceil \\frac{n}{k} \\rceil$，这是个经典的整除分块形式，$k$ 接近 $n$ 的时候，次数约为 $n$，暴力模拟无法接受，所以考虑将 $\\lceil \\frac{n}{k} \\rceil$ 相同的段一起处理。\n\n设 $\\lceil \\frac{n}{k} \\rceil=d$，要找到一个最小的 $c$ 使得 $\\lceil \\frac{n-cd}{k} \\rceil < d$，化为不等式处理，即 $\\frac{n-cd}{k}\\le d - 1$，解出 $c \\ge \\frac{n-k(d-1)}{d}$，所以这段的轮数为 $c=\\lceil \\frac{n-k(d-1)}{d} \\rceil=\\lfloor \\frac{n-k(d-1)-1}{d} \\rfloor + 1$。\n\n然后考虑第二部分，如果操作一次后在第 $p$ 个位置，那么对它及前面的每 $k-1$ 个元素，都是 $k$ 个元素删掉一个元素形成的（最后一段可能不足 $k-1$ 个元素），因此在它前面的被删掉的元素数为 $\\lceil \\frac{p}{k-1} \\rceil$，因此它原先是第 $p+\\lceil \\frac{p}{k-1} \\rceil$ 个元素。\n\n注意到 $ \\lceil \\frac{p}{k-1} \\rceil $ 的变化次数也是 $\\mathcal{O}(\\sqrt n)$ 的，所以同样类似地整除分块处理即可，总时间复杂度 $ \\mathcal{O}(\\sqrt n) $。\n\n{% fold C. Coin 示例代码 %}\n```cpp C. Coin\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline long long f(long long n, long long k) {\n    // 计算游戏需要几轮才能结束\n    long long ans = 0;\n    while(n) {\n        long long d = (n + k - 1) / k;\n        long long c = (n - k * (d - 1) - 1) / d + 1;\n        n -= c * d; ans += c;\n    }\n    return ans - 1;\n}\nlong long g(long long p, long long k, long long C) {\n    // 这里传进的 k 实际上为分母 k - 1\n    // C 表示剩余轮数\n    if(C == 0) return p;\n    long long d = (p + k - 1) / k;\n    long long x = (k * d - p) / d + 1;\n    x = min(x, C);\n    return g(p + x * d, k, C - x);\n}\n\ninline void solve() {\n    long long n, k; cin >> n >> k;\n    cout << g(1, k - 1, f(n, k)) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## D. Dolls\n\n**引理**：若一个序列可以被完全合并，则它的任一子区间都可以被完全合并，\n\n根据引理可以得到：若一个区间不可以被完全合并，则所有包含它的区间都不能被完全合并。\n\n因此可以从左往右考虑，每次贪心地合并最长的一段区间，否则不会更优。\n\n给定左端点，二分最大的可能的右端点，问题化为如何检查一个序列是否可以被完全合并。不断合并两个相邻的、紧挨着的套娃，若最后只剩下一个套娃则可以被完全合并（例如，$[2, 4]$ 与 $[5, 5]$ 就是两个紧挨着的套娃，它们合并变为 $[2, 5]$），注意这里需要先离散化。\n\n如果每次右端点初始值都设为 $n$，那么总的时间复杂度为 $\\mathcal{O}(n^2 \\log^2 n)$，无法承受，我们需要保证二分的长度和为 $\\mathcal{O}(n)$ 级别的，这样时间复杂度就降为 $\\mathcal{O}(n \\log^2 n)$，为此，可以对每个左端点先倍增出第一个不可合并的右端点位置（倍增检查的的区间长度为 $2^k$），并将它设为二分的右端点，此时区间长度不超过二倍的最长区间长度，因此二分的长度和不超过 $2n$，总时间复杂度降为 $\\mathcal{O}(n \\log^2 n)$。\n\n{% fold D. Dolls 示例代码 %}\n```cpp D. Dolls\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, A[N];\n\ninline bool merge_check(pair<int, int> a, pair<int, int> b) {\n    if(a.first > b.first) swap(a, b);\n    return a.second + 1 == b.first;\n}\ninline pair<int, int> merge(pair<int, int> a, pair<int, int> b) {\n    if(a.first > b.first) swap(a, b);\n    return {a.first, b.second};\n}\n\ninline bool check(int l, int r) {\n    vector<int> v(A + l, A + r + 1);\n    vector<int> lsh = v;\n    int n = r - l + 1;\n    sort(lsh.begin(), lsh.end());\n    for(int i = 0; i < n; i ++)\n        v[i] = lower_bound(lsh.begin(), lsh.end(), v[i]) - lsh.begin();\n    vector<pair<int, int>> stk;\n    stk.push_back({v[0], v[0]});\n    for(int i = 1; i < n; i ++) {\n        stk.push_back({v[i], v[i]});\n        while(stk.size() >= 2 && merge_check(stk[stk.size() - 2], stk[stk.size() - 1])) {\n            stk[stk.size() - 2] = merge(stk[stk.size() - 2], stk[stk.size() - 1]);\n            stk.pop_back();\n        }\n    }\n    return stk.size() == 1;\n}\n\ninline void solve() {\n    cin >> n;\n    for(int i = 1; i <= n; i ++)\n        cin >> A[i];\n    int s = 0;\n    for(int l = 1; l <= n; l ++) {\n        int L = l + 1, R = l + 1, d = 2;\n        while(R <= n && check(l, R)) \n            d <<= 1, R = min(n + 1, l + d - 1);\n        R --;\n        while(L < R) {\n            int mid = (L + R + 1) >> 1;\n            if(check(l, mid)) L = mid;\n            else R = mid - 1;\n        }\n        s ++, l = R;\n    }\n    cout << (n - s) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## E. Extracting Weights\n\n距离为 $k$ 的点对至多有 $\\mathcal{O}(n^2)$ 个，将每个看作是一个方程 $w_{u_0} \\oplus w_{u_1} \\oplus \\cdots \\oplus w_{u_k}=C$，，特别地，初始时给定了方程 $w_0=0$ ，只需要检验这些方程能否消元得到解。\n\n为此可以一个一个地将方程插入线性基，检验最后是否可以插入 $n-1$ 次（初始已经有方程 $w_0=0$），如果可行，就询问线性基中的这 $n-1$ 个方程，最后消元求解。总的时间复杂度为 $\\mathcal{O}(\\frac{n^4}{w})$。\n\n{% fold E. Extracting Weights 示例代码 %}\n```cpp E. Extracting Weights\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst int N = 256;\nint n, k; vector<int> G[N];\ntypedef bitset<N> bs;\n\nbool vis[N]; bs B[N], val[N]; int cnt = 0; pair<int, int> pr[N];\ninline void insert(bs M, pair<int, int> pr) {\n    if(cnt == n) return;\n    bs MM = M;\n    while(true) {\n        int i = M._Find_first();\n        if(i > n) break;\n        if(!vis[i]) {\n            vis[i] = true, B[i] = M, val[i] = MM, ::pr[i] = pr;\n            cnt ++; return;\n        } else M ^= B[i];\n    }\n}\nint anc;\nvoid dfs(int u, int fa, bs &M, int dep) {\n    M.flip(u);\n    if(dep == k) {\n        if(anc <= u) insert(M, {anc, u});\n        M.flip(u);\n        return;\n    }\n    for(int v : G[u]) {\n        if(v == fa) continue;\n        dfs(v, u, M, dep + 1);\n    }\n    M.flip(u);\n}\n\ninline void calc(vector<pair<bs, int>> &v) {\n    for(int i = 1; i < n; i ++) {\n        for(int j = 1; j <= i; j ++)\n            if(v[i].first[j]) {\n                v[i].first ^= v[j - 1].first;\n                v[i].second ^= v[j - 1].second;\n            }\n    }\n    for(int i = n - 2; i >= 0; i --) {\n        for(int j = n; j > i + 1; j --)\n            if(v[i].first[j]) {\n                v[i].first ^= v[j - 1].first;\n                v[i].second ^= v[j - 1].second;\n            }\n    }\n    for(int i = 0; i < n; i ++) {\n        v[i].first.flip(i+1);\n        assert(v[i].first.none());\n    }\n    cout << \"! \";\n    for(int i = 1; i < n; i ++) \n        cout << v[i].second << ' ';\n    cout << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    cin >> n >> k;\n    for(int i = 1; i < n; i ++) {\n        int a, b; cin >> a >> b;\n        G[a].emplace_back(b), G[b].emplace_back(a);\n    }\n    \n    bs a; a[1] = 1;\n    vis[1] = true, B[1] = val[1] = a, cnt ++;\n    bs M;\n    for(int i = 1; i <= n; i ++)\n        anc = i, dfs(i, 0, M, 0);\n    if(cnt == n) {\n        cout << \"YES\" << endl;\n        cout << \"? \" << n - 1 << ' ';\n        for(int i = 2; i <= n; i ++) \n            cout << pr[i].first << ' ' << pr[i].second << ' ';\n        cout << endl;\n        vector<int> ans(n + 1, 0);\n        for(int i = 2; i <= n; i ++)\n            cin >> ans[i];\n        vector<pair<bs, int>> vec(n);\n        for(int i = 1; i <= n; i ++)\n            vec[i - 1] = {val[i], ans[i]};\n        calc(vec);\n    } else cout << \"NO\" << endl;\n\n    return 0;\n}\n```\n{% endfold %}\n\n## G. GCD\n\n首先，答案一定不会超过 $26$，证明如下：\n\n假如两个数均为偶数，那么将它们同时除以 $2$，答案不变。\n\n否则，它们的 $\\mathrm{gcd}$ 是一个奇数，选定 $a,b$ 中的一个奇数，将它减去 $\\mathrm{gcd}$，我们就通过至多两次操作将 $a,b$ 全部变为了偶数。而 $a \\le 5000 < 2^{13}$，因此至多 $25$ 步就能将 $a$ 变为 $0$，此时若 $b \\ne 0$，则仅需一次操作即可将 $b$ 变为 $0$。\n\n因此直接爆搜即可，步骤大于 $26$ 就剪掉。\n\n{% fold G. GCD 示例代码 %}\n```cpp G. GCD\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint ans;\nvoid dfs(long long a, long long b, int c) {\n    if(a == 0 && b == 0) {\n        ans = min(ans, c);\n        return;\n    }\n    if(c > ans) return;\n    if(a) dfs(a - __gcd(a, b), b, c + 1);\n    if(b) dfs(a, b - __gcd(a, b), c + 1);\n}\n\ninline void solve() {\n    long long a, b;\n    cin >> a >> b;\n    ans = 26;\n    dfs(a, b, 0);\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## H. Horizon Scanning\n\n将所有点极角排序，求相隔 $k$ 个位置的极角差值的最大值即可，时间复杂度 $\\mathcal{O}(n \\log n)$，瓶颈在排序。\n\n{% fold H. Horizon Scanning 示例代码 %}\n```cpp H. Horizon Scanning\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nint n, k; double theta[N];\n\ninline void solve() {\n    cin >> n >> k;\n    for(int i = 1; i <= n; i ++) {\n        int x, y; cin >> x >> y;\n        theta[i] = atan2(y, x);\n    }\n    double ans = 0;\n    sort(theta + 1, theta + n + 1);\n    for(int i = 1; i <= n; i ++) {\n        if(i + k <= n)\n            ans = max(ans, theta[i + k] - theta[i]);\n        else\n            ans = max(ans, theta[i + k - n] -  theta[i] + acos(-1) * 2);\n    }\n    cout << fixed << setprecision(10) << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## J. Just another Sorting Problem\n\n- 如果 $n=2$，那么`Alice`必胜。\n\n- 否则 $n \\ge 3$，此时设位置不对的数有 $c$ 个\n    - 若 $c=2$，则谁先手谁获胜\n    - 否则，`Alice`获胜当且仅当 $n=3$ 且`Bob`先手，证明就是讨论一下`Bob`能否使得`Alice`在每次操作前都维持 $c \\ge 3$\n\n{% fold J. Just another Sorting Problem 示例代码 %}\n```cpp J. Just another Sorting Problem\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void solve() {\n    int n; string S;\n    cin >> n >> S;\n    int c = 0;\n    for(int i = 1; i <= n; i ++) {\n        int x; cin >> x;\n        if(x != i) c ++;\n    }\n    if(n >= 3) {\n        if(c == 2) cout << S << '\\n';\n        else if(n == 3) {\n            if(S == \"Alice\") cout << \"Bob\" << '\\n';\n            else cout << \"Alice\" << '\\n';\n        } else cout << \"Bob\" << '\\n';\n    } else cout << \"Alice\" << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## L. Last Chance: Threads of Despair\n\n设序列 $A$ 想要消灭序列 $B$，先用 $A$ 中不为 $1$ 的那些元素攻击 $B$ 中元素，最后一起爆炸一定最优。\n\n问题在于 $A$ 中那些不为 $1$ 的元素应该打谁：考虑将 $A,B$ 升序排序，维护当前最后可以连锁爆炸几次、还剩下多少刀可以打，每遇到一个最后解决不了的 $B$ 中元素就把它打到可以最后炸死的程度，然后让最后的爆炸次数加一。\n\n最后如果剩下一些刀（可以为 $0$）说明答案为`Yes`，否则为`No`。时间复杂度 $\\mathcal{O}(n \\log n + m \\log m)$，瓶颈在排序。\n\n{% fold L. Last Chance: Threads of Despair 示例代码 %}\n```cpp L. Last Chance: Threads of Despair\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5e5 + 10;\nint n, m, A[N], B[N];\n\ninline void solve() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i ++)\n        cin >> A[i];\n    for(int i = 1; i <= m; i ++)\n        cin >> B[i];\n    sort(A + 1, A + n + 1), sort(B + 1, B + m + 1);\n    long long c = n; int k = 0;\n    for(int i = 1; i <= n; i ++)\n        k += (A[i] == 1);\n    if(k) c -= (k - 1);\n    int i = 1, j = 1; while(i <= n && A[i] == 1) i ++;\n    for(int x = 1; x <= n; x ++) A[x] --;\n    while(j <= m && c >= 0) {\n        while(true) {\n            if((j > m || B[j] > k) && (i > n || A[i] > k)) break;\n            while(j <= m && B[j] <= k) k ++, j ++;\n            while(i <= n && A[i] <= k) k ++, i ++;\n        }\n        if(j <= m) \n            c -= (B[j] - k), B[j] = k;\n    }\n    cout << (c >= 0 ? \"Yes\" : \"No\") << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n## M. Matrix Construction\n\n一种可能的构造方案是沿副对角线方向从小到大填入数字，例如：\n\n$$\n\\begin{pmatrix}\n1 &2 &4 &7\\\\\n3 &5 &8 &11\\\\\n6 &9 &12 &14\\\\\n10 &13 &15 &16\\\\\n\\end{pmatrix}\n$$\n\n证明：考虑相邻两个数一定在相邻的两个副对角线上，如果两对相邻的数（$a<b$ 和 $c<d$）所在的副对角线不同，那么由于处于左上方副对角线的元素一定更小，所以必然有\n\n- $a<c,b<d$\n- $c<a,d<b$\n\n中的一个成立，于是 $a+b \\ne c+d$ 自然成立\n如果位于相同的副对角线上，由于同一副对角线上元素是单调的，所以也不可能相等。\n\n{% fold M. Matrix Construction 示例代码 %}\n```cpp M. Matrix Construction\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void solve() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> A(n, vector<int>(m));\n    int k = 1;\n    for(int i = 0; i < m; i ++) \n        for(int j = 0; j <= i && j < n; j ++) \n            A[j][i - j] = k ++;\n    for(int i = 1; i < n; i ++) {\n        for(int d = 0; i + d < n && m - 1 - d >= 0; d ++)\n            A[i + d][m - 1 - d] = k ++;\n    }\n    cout << \"Yes\" << '\\n';\n    for(int i = 0; i < n; i ++)\n        for(int j = 0; j < m; j ++)\n            cout << A[i][j] << \" \\n\"[j == m - 1];\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n\n    int T; cin >> T;\n    while(T --) solve();\n\n    return 0;\n}\n```\n{% endfold %}\n\n","tags":["ICPC","题解"],"categories":["OI"]},{"title":"高等代数学习笔记","url":"/post/77682b85.html","content":"\n高等代数学习笔记\n\n<!--more-->\n\n## 行列式\n\n### Laplace 定理\n\n#### k 阶子式\n\n对于 $n$ 阶行列式 ${\\boldsymbol{A}}$，选定 $k$ 行 $i_1 < i_2 < \\cdots < i_k$ 和 $k$ 列 $j_1 < j_2 < \\cdots < j_k$，它们的 $k^2$ 个交点按照原先的排列顺序组成一个新的 $k$ 阶行列式，叫做 ${\\boldsymbol{A}}$ 的一个 **$k$ 阶子式**，记作\n\n$$\n{\\boldsymbol{A}}\\begin{pmatrix}i_1,i_2,\\cdots ,i_k\\\\j_1,j_2,\\cdots ,j_k\\end{pmatrix}\n$$\n\n划去这 $k$ 行 $k$ 列，余下元素构成一个 $n-k$ 阶子式，叫做该 $k$ 阶子式的**余子式**，它乘上符号 $(-1)^{\\sum_{m=1}^{k}i_m+j_m}$ 称作该 $k$ 阶子式的**代数余子式**。\n\n#### Laplace 定理\n\n对于任一 $n$ 阶行列式 ${\\boldsymbol{A}}=(a_{ij})$，取定 $k$ 行 $i_1,i_2,\\cdots ,i_k$，$|{\\boldsymbol{A}}|$ 等于这 $k$ 行形成的所有子式与其代数余子式乘积的和，也即：\n\n$$\n|{\\boldsymbol{A}}|=\\sum_{1 \\le j_1 <\\cdots < j_k \\le n} {\\boldsymbol{A}}\\begin{pmatrix}i_1,i_2,\\cdots ,i_k\\\\j_1,j_2,\\cdots ,j_k\\end{pmatrix}(-1)^{\\sum_{m=1}^{k}i_m+j_m}{\\boldsymbol{A}}\\begin{pmatrix}i'_1,i'_2,\\cdots ,i'_{n-k}\\\\j'_1,j'_2,\\cdots ,j'_{n-k}\\end{pmatrix} \n$$\n\n其中 $\\{i'\\}$、$\\{j'\\}$ 分别为余子式的行号、列号（升序）。\n\n**证明：** 欲证 \n\n$$\n\\begin{aligned}\n|{\\boldsymbol{A}}|&=\\sum_{1 \\le j_1 < \\cdots < j_k \\le n} (-1)^{\\sum_{m=1}^{k}i_m+j_m}\\sum_{\\{u_k\\}} (-1)^{\\sigma(u)} a_{i_1u_1}\\cdots a_{i_ku_k}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(v)}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\\\\\n&=(-1)^{\\sum_{m=1}^{k}i_m}\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sum_{m=1}^{k}u_k}(-1)^{\\sigma(u)+\\sigma(v)}a_{i_1u_1}\\cdots a_{i_ku_k} a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}} \n\\end{aligned}\\tag{1}\n$$\n\n其中第一个等号处的序列 $u$ 为子式的列号 $j$ 的一个排列，将枚举 $\\{j\\}$ 再排列合并为一步：直接枚举 $1 \\sim n$ 的一个 $k$ 元排列 $\\{u\\}$，化至第二个等号；而对于序列 $v$，它枚举的是余子式的列号的排列。\n\n已知 \n\n$$\n|{\\boldsymbol{A}}|=\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(ii')+\\sigma(uv)}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n其中 $ii'$ 表示将序列 $i$、$i'$ 拼接起来得到的新序列，$uv$ 同理。\n\n欲证两式相等，先证一个引理：\n\n**引理1**：设 $a,b$ 为两个长度为 $n,m$ 的序列，序列中元素构成 $1 \\sim n+m$ 的一个排列，那么\n\n$$\n(-1)^{\\sigma(ab)}=(-1)^{\\sigma(a)+\\sigma(b)}(-1)^{\\left(\\sum_{i=1}^{n}a_i\\right)+\\frac{n(n+1)}{2}}\n$$\n\n**证明**：设将 $a$ 进行 $s$ 次对换可以使其升序排列为 $a'$，那么 $(-1)^{\\sigma(a)}=(-1)^s$，同时有\n\n$$\n(-1)^{\\sigma(ab)}=(-1)^s(-1)^{\\sigma(a'b)}\n$$\n\n考虑 $a'b$ 的逆序数，$a'_k$ 对于逆序数的贡献为 $a'_k-k$（比他小的数有 $a'_k-1$ 个，其中 $k-1$ 个在它之前），因此\n\n$$\n(-1)^{\\sigma(a'b)}=(-1)^{\\sum_{k=1}^{n}(a'_k-k)}(-1)^{\\sigma(b)}\n$$\n\n带回原式即可得到\n\n$$\n(-1)^{\\sigma(ab)}=(-1)^{\\sigma(a)+\\sigma(b)}(-1)^{\\left(\\sum_{k=1}^{n}a_k\\right)+\\frac{n(n+1)}{2}}\n$$\n\n证毕！\n\n回到原命题，已知\n\n$$\n|{\\boldsymbol{A}}|=\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(ii')+\\sigma(uv)}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n拆开 $(-1)^\\sigma$ 得到\n\n$$\n\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(i)+\\sigma(i')+\\sigma(u)+\\sigma(v)}(-1)^{\\sum_{m=1}^{k}i_k+u_k}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n而 $\\{i\\}$ 和 $\\{i'\\}$ 都是升序的，故 $\\sigma(i)=\\sigma(i')=0$，于是上式等于\n\n$$\n\\sum_{\\{u_k\\}}\\sum_{\\{v_{n-k}\\}}(-1)^{\\sigma(u)+\\sigma(v)}(-1)^{\\sum_{m=1}^{k}i_k+u_k}a_{i_1u_1}\\cdots a_{i_ku_k}a_{i'_1v_1}\\cdots a_{i'_{n-k}v_{n-k}}\n$$\n\n这与式 $(1)$ 是一致的，证毕！\n\n#### 推论\n\n行列式可以分块计算，换句话说，\n\n$$\n\\begin{vmatrix}\n{\\boldsymbol{A}}&0\\\\\n{\\boldsymbol{B}}&{\\boldsymbol{C}}\n\\end{vmatrix}\n$$\n\n其中 ${\\boldsymbol{A}}$、${\\boldsymbol{B}}$、${\\boldsymbol{C}}$ 都是 $k$ 阶方阵，那么我们将它按照前 $k$ 行展开，子式不为零当且仅当恰取了前 $k$ 列，于是根据 Laplace 定理，\n\n$$\n\\begin{vmatrix}\n{\\boldsymbol{A}}&0\\\\\n{\\boldsymbol{B}}&{\\boldsymbol{C}}\n\\end{vmatrix}=|{\\boldsymbol{A}}|\\cdot |{\\boldsymbol{C}}|\n$$\n\n## 线性空间\n\n### 定义与性质\n\n设 $(V,+)$ 是一个 Abel 群，$\\mathbb{P}$ 是一个数域。定义 $\\mathbb{P}$ 与 $V$ 的一个代数运算数乘 $\\cdot$，运算结果仍然在 $V$ 中。\n\n令 $a,b \\in {\\mathbb{P}}$，$\\boldsymbol{u},\\boldsymbol{v} \\in V$，若满足：\n\n1. $\\cdot$ 对 $(V,+)$ 的分配律 $a\\cdot (\\boldsymbol{u}+\\boldsymbol{v})=a\\cdot\\boldsymbol{u}+a\\cdot\\boldsymbol{v}$\n2. 数乘对标量加法的分配律 $(a+b)\\cdot \\boldsymbol{u}=a \\cdot \\boldsymbol{u} + b \\cdot \\boldsymbol{u}$\n3. 数乘的结合律 $a(b\\boldsymbol{u})=(ab)\\boldsymbol{u}$\n4. 标量乘法具有单位元，令 $1 \\in {\\mathbb{P}}$ 是 $\\mathbb{P}$ 的单位元，则 $1\\boldsymbol{u}=\\boldsymbol{u}$\n\n则称代数系统 $(V,+,\\cdot ,{\\mathbb{P}})$ 是 $V$ 关于 $+,\\cdot$ 构成1 $\\mathbb{P}$ 上的一个**线性空间**，并称加法群中的零元为**零向量**，记作 $\\boldsymbol{0}$。\n\n任取 $\\boldsymbol{\\alpha_1},\\boldsymbol{\\alpha_2},\\cdots ,\\boldsymbol{\\alpha_n} \\in V$，那么 $U=\\{k_1\\boldsymbol{\\alpha_1}+k_2\\boldsymbol{\\alpha_2}+\\cdots +k_n\\boldsymbol{\\alpha_n} \\vert\\forall 1 \\le i \\le n, k_i \\in {\\mathbb{P}}\\}$ 构成一个子空间，我们将该子空间记作 $\\{ \\boldsymbol{\\alpha_1},\\boldsymbol{\\alpha_2},\\cdots ,\\boldsymbol{\\alpha_n} \\}$，于是可以将线性方程组看作如下形式：\n\n$$\n\\begin{pmatrix}a_{11}\\\\ a_{21}\\\\ \\vdots \\\\ a_{m1} \\end{pmatrix}x_1+\\begin{pmatrix}a_{12}\\\\ a_{22}\\\\ \\vdots \\\\ a_{m2} \\end{pmatrix}x_2+\\cdots +\\begin{pmatrix}a_{1n}\\\\ a_{2n}\\\\ \\vdots \\\\ a_{mn} \\end{pmatrix}x_n=\\begin{pmatrix}b_1\\\\ b_2\\\\ \\vdots \\\\ b_m \\end{pmatrix}\n$$\n\n于是我们其实就是在研究 向量 $\\boldsymbol{b}$ 是否在这 $n$ 个列向量 $\\boldsymbol{a_i}$ 张成的子空间内。\n\n### 线性相关与线性无关\n\n对于一个向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$，若存在不全为 $0$ 的数组 $k_1,\\cdots ,k_n$ 使得 \n\n$$\n\\sum_{i=1}^{n}k_i\\boldsymbol{\\alpha_i}=\\boldsymbol{0}\n$$\n\n则称这个向量组**线性相关**，否则称它**线性无关**。显然，只有零向量的向量组就是一个线性相关的向量组，任何含零向量的向量组必然线性相关。\n\n不加证明地给出如下结论（证明平凡）：\n\n**定理 1**：一个向量组线性无关当且仅当其中的任意一个向量不能被其余向量线性表出。\n\n**定理 2**：若 $\\boldsymbol{\\beta}$ 可以被一个向量组表出，则表出方式唯一等价于该向量组线性无关。\n\n**定理 3**：设向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$ 线性无关，则向量 $\\boldsymbol{\\beta}$ 可以被该向量组表出当且仅当向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}, \\boldsymbol{\\beta}$ 线性相关。\n\n**定理 4**：任意一个极大线性无关向量组张成的空间与原向量组张成的空间相同。\n\n**定义**：称两个线性空间相同当且仅当其可表出的向量相同，记作 $V_1 \\cong V_2$，其中 $V_1,V_2$ 为两个线性空间。\n\n### 向量组的秩\n\n**引理 1**：设 $n > m$，且向量组 $\\{ \\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n} \\}$ 可以被向量组 $\\{ \\boldsymbol{\\beta_1}, \\cdots ,\\boldsymbol{\\beta_m} \\}$ 线性表出，那么前者一定线性相关。\n\n**证明**：只需证 $x_1\\boldsymbol{\\alpha_1}+\\cdots +x_n\\boldsymbol{\\alpha_n}=\\boldsymbol{0}$ 有非零解，由已知，不妨设 $\\boldsymbol{\\alpha_k}=\\sum_{i=1}^{m}c_{ik}\\boldsymbol{\\beta_i}$，于是原式化为\n\n$$\n\\sum_{k=1}^{n}x_k\\sum_{i=1}^{m}c_{ik}\\boldsymbol{\\beta_i}=\\boldsymbol{0}\n$$\n\n整理得\n\n$$\n\\sum_{i=1}^{m}\\boldsymbol{\\beta_i}\\sum_{k=1}^{n}c_{ik}x_k=\\boldsymbol{0}\n$$\n\n要使上式成立，仅需 $\\sum_{k=1}^{n}c_{ik}x_k=0$ 对任意 $i$ 成立，问题归结为齐次线性方程组\n\n$$\n\\begin{cases}\nc_{11}x_1+c_{12}x_2+\\cdots +c_{1n}x_n=0\\\\\nc_{21}x_1+c_{22}x_2+\\cdots +c_{2n}x_n=0\\\\\n\\cdots \\\\\nc_{m1}x_1+c_{m2}x_2+\\cdots +c_{mn}x_n=0\\\\\n\\end{cases}\n$$\n\n是否有非零解，由于方程组个数 $m$ 小于未知数个数 $n$，所以这样的齐次线性方程组有无穷多组解，于是自然存在非零解，证毕！\n\n**推论 1**：考虑引理 1 的逆否命题，向量组 $\\{ \\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n} \\}$ 可以被向量组 $\\{ \\boldsymbol{\\beta_1}, \\cdots ,\\boldsymbol{\\beta_m} \\}$ 线性表出，若前者线性无关，则必然有 $n \\le m$。\n\n**推论 2**：等价的线性无关向量组中，向量的个数必然相同。\n\n**推论 3**：一个向量组的所有极大线性无关向量组中的向量个数相同。\n\n**定义**：由推论 3，我们可以得出**秩**的定义，一个向量组的秩就是其极大线性无关向量组中向量的个数，记作 $\\operatorname{rank} \\{ \\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n} \\}$。特别地，只含零向量的向量组的秩为 $0$。\n\n因此，向量组线性无关等价于其秩恰为其中向量个数，即 $\\operatorname{rank}\\{\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}\\}=n$。\n\n**推论 4**：若向量组 $\\boldsymbol{(I)}$ 可被向量组 $\\boldsymbol{(II)}$ 线性表出，则 $\\operatorname{rank} \\boldsymbol{(I)} \\le \\operatorname{rank} \\boldsymbol{(II)}$ \n\n**推论 5**：等价的向量组具有相等的秩。\n\n### 线性空间的基\n\n**定义**：对于线性空间 $V$，其有限子集 $V_0=\\{\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}\\}$ 线性无关当且仅当向量组 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$ 线性无关；其无限子集 $S$ 线性无关当且仅当 $S$ 的所有有限子集均线性无关。\n\n**定义**：设 $V$ 是一个线性空间，若其子集 $S$ 满足：\n\n- $S$ 线性无关\n- $V$ 中任一向量均可被 $S$ 线性表出\n\n则称 $S$ 是 $V$ 的一个**基**。特别地，定义空基线性无关，于是只含零向量的线性空间的一个基为空基。\n\n**定理 5**：任一数域上的任一线性空间都有一个基。\n\n证明略去。\n\n**定义**：若 $V$ 存在一个基是有限子集，则称 $V$ 是有限维的；若 $V$ 存在一个基是无限子集，则称 $V$ 是无限维的。\n\n**定理 6**：若 $V$ 是有限维的，则它的所有基中的向量个数相同。\n\n**推论 6**：无限维的线性空间的基都是无限集。\n\n**定义**：假设 $V$ 是有限维的线性空间，称其任一基中所含的向量个数称为 $V$ 的**维数**，记作 $\\operatorname{dim} V$ 或 $\\operatorname{dim}_{\\mathbb{P}} V$，其中 $\\mathbb{P}$ 为数域。若 $V$ 是无限维的空间，则称 $\\operatorname{dim} V=\\infty$。特别地，只含零向量的线性空间的维数为 $0$。\n\n**定义**：设 $\\operatorname{dim} V=n$，则取 $V$ 的一个基 $\\boldsymbol{\\alpha_1},\\cdots ,\\boldsymbol{\\alpha_n}$，$V$ 中的任一向量 $\\boldsymbol{\\beta}$ 都能被唯一地表示为 $\\boldsymbol{\\beta}=\\sum_{k=1}^{n}c_k\\boldsymbol{\\alpha_k}$，此时称 $\\boldsymbol{\\beta}$ 的**坐标**为 $\\begin{pmatrix}c_1\\\\c_2\\\\ \\vdots \\\\ c_n\\end{pmatrix}$。","tags":["学习笔记","高等代数"],"categories":["数学"]},{"title":"Pell 方程","url":"/post/9861dc77.html","content":"\n内容基本来源于 [OI-wiki](https://oi-wiki.org/math/number-theory/pell-equation)\n\n<!--more-->\n\n## 定义与结构\n\n（广义）Pell 方程指关于 $x,y$ 的不定方程 \n\n$$\nx^2-Dy^2=C\n$$\n\n当 $D\\le 0$ 或为完全平方数时是平凡的，我们不予考虑，同时，解 $(\\pm 1,0)$ 也是平凡的，接下来的讨论中忽略该解。而狭义的 Pell 方程专指 $C=1$ 或 $C=\\pm 1$ 的特殊情况。\n\n对于一个二次整数 $x+y\\sqrt D$（它是一个二次方程的根），定义其范数为它与它的共轭的积，记为\n\n$$\nN(x+y\\sqrt D)=x^2-Dy^2\n$$\n\n所以，广义 Pell 方程大致相当于在求解范数为 $C$ 的二次整数，但并不等价，因为二次整数形如 $\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$，当 $D \\equiv 1 \\pmod 4$ 时， $x,y$ 可以同时为半整数。\n\n范数具有一些性质，这对 Pell 方程的求解至关重要。\n\n**Brahmagupta 恒等式** \n\n$$\n(x_1^2-Dy_1^2)(x_2^2-Dy_2^2)=(x_1x_2+Dy_1y_2)^2-D(x_1y_2+x_2y_1)^2\n$$\n\n证明显然。这说明了什么？这说明二次整数的范数保持乘法，也即\n\n$$\nN(x_1+y_1 \\sqrt D) \\cdot N(x_2+y_2 \\sqrt D)=N\\Big( (x_1+y_1\\sqrt D)(x_2+y_2\\sqrt D) \\Big)\n$$\n\n利用这个性质，假如我们知道了 $x^2-Dy^2=N_1$ 的一组解和 $x^2-Dy^2=N_2$ 的一组解，我们就能立刻写出 $x^2-Dy^2=N_1N_2$ 的一组解。正因 Pell 方程的解和二次整数的紧密联系，我们将解 $(x,y)$ 直接写成 $x+y\\sqrt D$ 的形式。\n\n同时，由于 Pell 方程表示的是一个双曲线的方程，所以我们只需要找到第一象限的所有解即可。\n\n在下文中，我们只探讨狭义 Pell 方程的求解，文章开头的链接中给出了广义 Pell 方程的求解方式，但这里暂时不作延申。\n\n## 狭义 Pell 方程的求解\n\n由上文可知，如果存在一个解 $x_1+y_1\\sqrt D$，那么所有 $(x_k+y_k \\sqrt D)=(x_1+y_1\\sqrt D)^k$ 都将是 Pell 方程的解（范数的积性），我们先声称存在一个基本解（使 $x_1+y_1\\sqrt D$ 最小的 $(x_1,y_1)$），下面证明它的 $k$ 次幂 $x_k+y_k \\sqrt D$ 可以得到所有解。\n\n不妨设第一象限中存在一个另外的解 $x_k+y_k\\sqrt D < x+y\\sqrt D < x_{k+1}+y_{k+1}\\sqrt D$，两侧同时乘 $x_k-y_k\\sqrt D$ 得到\n\n$$\n1 < (xx_k-Dyy_k)+(x_ky-xy_k)\\sqrt D < x_1+y_1\\sqrt D\n$$\n\n这与 $x_1+y_1 \\sqrt D$ 最小矛盾！\n\n下面，我们给出 Pell 方程基本解的构造性证明。\n\n### PQa 算法\n\nPQa 算法可以得出特定的二次无理数的连分数展开。设整数 $P_0,Q_0,D$ 满足 $Q_0 \\ne 0$，$D > 0$ 且不是完全平方数，且 $P_0^2 \\equiv D \\pmod {Q_0}$，那么二次无理数\n\n$$\n\\omega=\\frac{P_0+\\sqrt D}{Q_0}\n$$\n\n的连分数展开 $[a_0,a_1,\\cdots]$ 可以由如下递推求得：\n\n$$\n\\begin{cases}\na_k=\\left\\lfloor \\frac{P_k+\\sqrt D}{Q_k} \\right\\rfloor\\\\\nP_{k+1}=a_kQ_k-P_k\\\\\nQ_{k+1}=\\frac{D-P_{k+1}^2}{Q_k}\n\\end{cases}\n$$\n\n进而， $\\omega$ 的第 $k$ 个渐进分数的分子和分母 $A_k$ 和 $B_k$ 由如下递推给出：\n\n$$\n\\begin{cases}\nA_k=a_kA_{k-1}+A_{k-2}\\\\\nB_k=a_kB_{k-1}+B_{k-2}\n\\end{cases}\n$$\n\n其中 $A_{-1}=1$，$A_{-2}=0$，$B_{-1}=0$，$B_{-2}=1$\n\n证明可以参见 [OI-wiki](https://oi-wiki.org/math/number-theory/continued-fraction/)，也可以看 [ProjectEuler板刷记录](https://la-syh.blog/post/7399281c.html) 中的`Problem 64`。\n\n记 $\\omega = [a_0,\\cdots ,a_{k_0-1},\\overline{a_{k_0},\\cdots ,a_{k_0+l-1}}]$，下面我们利用 PQa 算法解决 Pell 方程。\n\n::: {.theorem .unnumbered#定理}\n设 $G_k=Q_0A_k-P_0B_k$，则整数对 $(G_{k-1},B_{k-1})$ 满足 \n\n$$\nG_{k-1}^2-DB_{k-1}^2=(-1)^kQ_0Q_k\n$$\n\n且它们的最大公因数 $\\operatorname{gcd}(G_{k-1},B_{k-1})$ 整除 $Q_k$\n:::","tags":["学习笔记","数论"],"categories":["数学"]},{"title":"ProjectEuler板刷记录","url":"/post/7399281c.html","content":"\n本文收录一些[ProjectEuler](https://projecteuler.net/)中有趣的题目并给出个人题解。\n\n<!--more-->\n\n**[Problem 54](https://projecteuler.net/problem=54)**\n\n本题并不困难，只是一个简单的模拟，但是如何让代码量减小是一个值得讨论的问题。\n\n首先，我们可以将牌的点数和花色分开存储，我们只关心“所有牌的花色是否均相同”而不关注“每个牌的花色是多少”，所以可以分别排序。\n\n之后，写一个函数level(card, color)来返回手牌的等级（数字越大，等级越高），若两人等级不同则直接判断，否则需要进一步比较具体点数。\n\n这里是减少代码量的关键一步：不必对每一个等级都写一个具体的比较，注意到只有`Flush`的比较策略是不同的：每次拿剩下的最大手牌比较。\n\n对于剩下的等级，我们只需对每个玩家存储：对每个k，出现过k次的牌的点数是什么。之后，依次比较出现过4次、3次、2次、1次的牌的点数大小即可。\n\n{% fold Problem 54 示例代码 %}\n```py Problem 54\nwith open('0054_poker.txt', 'r') as file:\n    content = file.readlines()\n\nans = 0\ndef init(str):\n    if ord(str[0]) >= ord('2') and ord(str[0]) <= ord('9'):\n        return ord(str[0]) - ord('0')\n    if str[0] == 'T':\n        return 10\n    if str[0] == 'J':\n        return 11\n    if str[0] == 'Q':\n        return 12\n    if str[0] == 'K':\n        return 13\n    if str[0] == 'A':\n        return 14\n    return -1\ndef level(card, color):\n    straight = True\n    for k in range(1, 5):\n        if card[k] != card[k - 1] + 1:\n            straight = False\n    if color[0] == color[4]:\n        if straight and card[0] == 10:\n            return 10\n        elif straight:\n            return 9\n    if card[0] == card[3] or card[1] == card[4]:\n        return 8\n    if (card[0] == card[2] and card[3] == card[4]) or (card[0] == card[1] and card[2] == card[4]):\n        return 7\n    if color[0] == color[4]:\n        return 6\n    if straight:\n        return 5\n    if card[0] == card[2] or card[1] == card[3] or card[2] == card[4]:\n        return 4\n    pairs_count = 0\n    k = 0\n    while k < 4:\n        if card[k] == card[k + 1]:\n            pairs_count += 1\n            k += 1\n        k += 1\n    if pairs_count == 2:\n        return 3\n    if pairs_count == 1:\n        return 2\n    return 1\ndef beat(Alice, Bob):\n    level_Alice = level(Alice[0], Alice[1])\n    level_Bob = level(Bob[0], Bob[1])\n    if level_Alice != level_Bob:\n        return level_Alice > level_Bob\n    if level_Alice == 6:\n        k = 4\n        while True:\n            if Alice[0][k] != Bob[0][k]:\n                return Alice[0][k] > Bob[0][k]\n            k -= 1\n    A = [[], [], [], [], []]\n    B = [[], [], [], [], []]\n    for k in range(2, 15):\n        A[Alice[0].count(k)].append(k)\n        B[Bob[0].count(k)].append(k)\n    for k in range(1, 5):\n        A[k].sort(reverse = True)\n        B[k].sort(reverse = True)\n    k = 4\n    while True:\n        for i in range(len(A[k])):\n            if A[k][i] != B[k][i]:\n                return A[k][i] > B[k][i]\n        k -= 1\ndef work(arr):\n    global ans\n    arr = arr.split()\n    Alice = [[init(arr[k]) for k in range(0, 5)], [arr[k][1] for k in range(0, 5)]]\n    Bob = [[init(arr[k]) for k in range(5, 10)], [arr[k][1] for k in range(5, 10)]]\n    for k in range(0, 2):\n        Alice[k].sort()\n        Bob[k].sort()\n    # print(Alice)\n    # print(Bob)\n    if beat(Alice, Bob):\n        ans += 1\nfor line in content:\n    work(line)\nprint(ans)\n```\n{% endfold %}\n\n**[Problem 59](https://projecteuler.net/problem=59)**\n\n简单有趣的一道题。可以通过字母频率分析猜一猜密钥，如果懒得做的话可以像我一样直接枚举。\n\n得到所有可能的原文章后，我们要筛选出有意义的那一个，当然不能一个一个去看，可以在Sublime Text里搜索几个常见词汇，比如我搜索了` the `（两侧带空格），直接可以得到密钥是`exp`，问题就结束了。\n\n{% fold Problem 59 代码 %}\n```py 得到所有可能的原串\ntext = []   # 填入所给文件内容\nkey = [0, 0, 0]\ndef work():\n    id = 0\n    T = text.copy()\n    for i in range(len(T)):\n        T[i] = chr(T[i] ^ key[id])\n        id += 1\n        if id == 3:\n            id = 0\n    str = ''\n    for c in T:\n        str += c\n    with open('output.txt', 'a') as f:\n        for k in range(0, 3):\n            f.write(chr(key[k]))\n        f.write('\\n')\n        f.write(str)\n        f.write('\\n')\nfor a in range(ord('a'), ord('z') + 1):\n    key[0] = a\n    for b in range(ord('a'), ord('z') + 1):\n        key[1] = b\n        for c in range(ord('a'), ord('z') + 1):\n            key[2] = c\n            work()\n```\n\n```py 已知密钥求答案\ntext = []   # 填入所给文件内容\nkey = [ord('e'), ord('x'), ord('p')]\nid = 0\nfor i in range(len(text)):\n    text[i] = text[i] ^ key[id]\n    id += 1\n    if id == 3:\n        id = 0\nans = 0\nfor x in text:\n    ans += x\nprint(ans)\n```\n{% endfold %}\n\n**[Problem 60](https://projecteuler.net/problem=60)**\n\n本题是前60道题中难度最大的一道，但是也比较常规。\n\n考虑转化到图论上。如果两个素数的拼接仍然是素数，就在它们之间连边，要求的就是数字和最小的 $K_5$ 子图。这种东西就直接爆搜，远远跑不满五次方的上界，可以在 $8$ 秒内跑出结果，如果用某些工程库的求 $K_5$ 子图模板可以更快，但没必要。\n\n本题中如果没有提前建好图，而是在爆搜过程中不断调用`isprime`会巨慢无比，什么东西都跑不出来，笔者最开始就是因为这个卡住了。\n\n{% fold Problem 60 示例代码 %}\n```py Problem 60\nimport math\nimport time\nimport sympy\nSTART = time.time()\n\nN = int(1e6) + 10\nd = [0] * N\nprimes = []\ndef Sieve(n):\n    d[1] = 1\n    for i in range(2, n + 1):\n        if d[i] == 0:\n            d[i] = i\n            primes.append(i)\n        for x in primes:\n            if x * i > n:\n                break\n            d[x * i] = x\n            if(i % x == 0):\n                break\nSieve(int(1e4))\ndef check(a, b):\n    return sympy.isprime(int(str(a) + str(b))) and sympy.isprime(int(str(b) + str(a)))\nedges = [[] for _ in range(len(primes))]\nfor i in range(len(primes)):\n    for j in range(i + 1, len(primes)):\n        if check(primes[i], primes[j]):\n            edges[i].append(j)\n            edges[j].append(i)\nprint('Total nodes:', len(primes))\n\nans = int(1e18)\nval = [0, 0, 0, 0, 0]\ndef dfs(dep):\n    global ans, val\n    if dep == 5:\n        S = 0\n        for k in range(5):\n            S += primes[val[k]]\n        print(val)\n        ans = min(ans, S)\n        print(ans)\n        return\n    for i in range(len(primes)):\n        if primes[i] == 5:\n            continue\n        if dep != 0 and i <= val[dep - 1]:\n            continue\n        val[dep] = i\n        flag = True\n        for j in range(0, dep):\n            if not edges[i].count(val[j]):\n                flag = False\n                break\n        if flag:\n            dfs(dep + 1)\ndfs(0)\nprint('Result =', ans)\n\nEND = time.time()\nprint(f\"耗时:{END - START:.4f}秒\")\n```\n{% endfold %}\n\n**[Problem 64](https://projecteuler.net/problem=64)**\n\n以连分数为背景的一道题，正好来学习一下相关内容。\n\n定理：所有循环连分数都是二次无理数，且任何一个二次无理数都可以写成循环连分数的形式。\n\n证明：先证明所有循环连分数都是二次无理数。对于一般的循环连分数 $x=[a_0,\\cdots, a_{k-1},\\overline{a_k,\\cdots ,a_{k+L+1}}]$，设 $y=[\\overline{a_k, \\cdots, a_{k+L+1}}]$，则\n\n$$\n\\begin{aligned}\n&x=[a_0,\\cdots, a_{k-1},\\overline{a_k,\\cdots ,a_{k+L+1}}]=L_0(y)\\\\\n&y=[\\overline{a_k, \\cdots, a_{k+L+1}}]=L_1(y)\n\\end{aligned}\n$$\n\n其中 $L_0$ 和 $L_1$ 都是分式线性变换，于是得到\n\n$$\nx=L_0 \\circ L_1 \\circ L_0^{-1}(x)\n$$\n\n右侧的复合仍然是一个分式线性变换，不妨设\n\n$$\nL_0 \\circ L_1 \\circ L_0^{-1}(x)=\\frac{ax+b}{cx+d}\n$$\n\n则得到关于 $x$ 的方程 $cx^2+(d-a)x-b=0$，因此循环连分数都是整系数二次方程的解，又因为无线连分数都是无理数，因此循环连分数表示了二次无理数。\n\n接下来，我们证明任意二次无理数都可以写成循环连分数，这是对于本题重要的一步，因为我们可以通过这个过程得到计算连分数形式的算法。\n\n首先，二次无理数总可以表示成 $x=\\frac{P_0+\\sqrt D}{Q_0}$ 的形式，其中 $P_0,Q_0,D$ 都是整数且 $Q_0 | D-P_0^2$。证明很容易，$\\frac{p_a}{q_a}+\\frac{p_b}{q_b}\\sqrt{D'}$可以通分为\n\n$$\n\\frac{p_ap_bq_aq_b+\\sqrt{(q_aq_b)^2D'}}{(q_aq_b)^2}\n$$\n\n令 $P=p_ap_bq_aq_b$，$Q=(q_aq_b)^2$，$D=QD'$ 即可。\n\n为什么要写成这样的形式？因为它的所有余项都有类似的形式：\n\n$$\nr_k=\\frac{P_k+\\sqrt{D}}{Q_k}\n$$\n\n其中 $P_k$，$Q_k$ 是整数并且 $Q_k | D-P_k^2$。其中，条件 $Q_k | D-P_k^2$保证了所有余项的分子中，$\\sqrt D$ 前面的系数都是 $1$。\n\n数学归纳求 $P_k$，$Q_k$ 的形式：设 $a_k=\\left\\lfloor r_k \\right\\rfloor$，那么 $r_k=a_k+\\frac{1}{r_{k+1}}$。\n\n设 $r_{k+1}$ 也有类似形式，带入得到\n\n$$\n\\frac{P_k+\\sqrt D}{Q_k}=a_k+\\frac{Q_{k+1}}{P_{k+1}+ \\sqrt D}=a_k+\\frac{Q_{k+1}P_{k+1}-Q_{k+1}\\sqrt D}{P_{k+1}^2-D}\n$$\n\n对比系数可得\n\n$$\n\\begin{cases}\nP_{k+1}=a_kQ_k-P_k\\\\\nQ_{k+1}=-a_k^2Q_k+2a_kP_k+\\frac{D-P_k^2}{Q_k}\n\\end{cases}\n$$\n\n实际应用时，可以用更简便的 $Q_{k+1}=\\frac{D-P_{k+1}^2}{Q_k}$\n\n根据 $Q_k | D-P_k^2$，所以 $P_{k+1}$ 和 $Q_{k+1}$ 确实都是整数，即 $r_{k+1}$ 确实具有要求的形式。\n\n到此，我们已经得到了求二次无理数的连分数形式的算法，下面证明余项只能取到有限多个值，因此必然存在循环节。\n\n已经求得余项为\n\n$$\n\\frac{P_k+\\sqrt D}{Q_k}=r_k=-\\frac{q_{k-2}x-p_{k-2}}{q_{k-1}x-p_{k-1}}\n$$\n\n对于无理数，总有 $r_k>1$，同时，其共轭 \n\n$$\nr_k^*=-\\frac{q_{k-2}}{q_{k-1}}\\frac{x^*-\\frac{p_{k-2}}{q_{k-2}}}{x^*-\\frac{p_{k-1}}{q_{k-1}}}\n$$\n\n因为 $q_{k-2}/q_{k-1}>0$ 并且 \n\n$$\n\\lim_{k \\to \\infty} \\frac{x^*-\\frac{p_{k-2}}{q_{k-2}}}{x^*-\\frac{p_{k-1}}{q_{k-1}}}=\\frac{x^*-x}{x^*-x}=1\n$$\n\n因此对充分大的 $k$，必然有 $r_k^*<0$，因此 \n\n$$\n\\frac{2\\sqrt D}{Q_k}=r_k-r_k^*>1\n$$\n\n得到\n\n$0 < Q_k \\le 2\\sqrt D$，因此 $Q_k$ 只能取有限个值，进一步由递推公式，$P_k$ 也只能取有限个值，证毕。\n\n代码就根据上面的递推写就行了，没什么难度。这里直接用了[OI-wiki](https://oi-wiki.org/math/number-theory/continued-fraction/#__tabbed_8_2)的实现。\n\n{% fold Problem 64 代码 %}\n```py Problem 64\n# Return the continued fraction and minimal positive period\n#   of a quadratic irrational (x + y * sqrt(n)) / z.\nimport math\ndef quadratic_irrational(x, y, z, n):\n    p = x * z\n    d = n * y * y * z * z\n    q = z * z\n    dd = math.floor(math.sqrt(n)) * y * z\n    i = 0\n    a = []\n    used = dict()\n    while (p, q) not in used:\n        a.append((p + dd) // q)\n        used[p, q] = i\n        p = a[-1] * q - p\n        q = (d - p * p) // q\n        i += 1\n    return a, i - used[p, q]\n\nans = 0\nfor k in range(1, 10000 + 1):\n    if int(math.sqrt(k)) ** 2 == k:\n        continue\n    if quadratic_irrational(0, 1, 1, k)[1] % 2 == 1:\n        ans += 1\nprint(ans)\n```\n{% endfold %}","tags":["习题"],"categories":["数学"]},{"title":"Machine Learning","url":"/post/c5317df1.html","tags":["学习笔记"]},{"title":"我常常追忆过去","url":"/post/ba11f26f.html","content":"\n我该在哪里停留？我问我自己。\n\n<!--more-->\n\n原名为《人，事，物》，记录了一些一中风景和人物。\n\n想说的所有话都已经给想说的人说出去了，遂删。","tags":["随笔"],"categories":["随笔"]}]